<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<title>Bitwa 6×3 (+bufor) — czerwony A, niebieski O</title>
<style>
  :root { --cell:120px; --gap:10px; --bg:#0f1220; --panel:#161a2f; --grid:#222846; --text:#e7e9f3; }
  html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font:14px/1.4 system-ui,Segoe UI,Roboto,sans-serif}
  .wrap{display:flex;gap:16px;padding:16px}
  .board-wrap{display:flex;flex-direction:column;gap:10px}
  .board{display:grid;grid-template-columns:repeat(8,var(--cell));grid-auto-rows:var(--cell);gap:var(--gap);background:var(--grid);padding:var(--gap);border-radius:12px;box-shadow:0 0 0 1px #0008 inset,0 8px 30px #0007}
  .cell{position:relative;border-radius:10px;display:flex;align-items:center;justify-content:center;outline:1px solid #0006;overflow:hidden;cursor:default}
  .coords{position:absolute;top:4px;left:6px;font-size:11px;opacity:.6}
  .plain{background:#283058} 
  /* LAS – obrazek zamiast gradientów */
  .forest{
    background:
      url('battle_images/forest.png') center / 100% 100% no-repeat;
    /* subtelny „rant”, jak wcześniej */
    box-shadow: inset 0 0 0 1px #0004;
    /* jeśli grafika jest pixel–artem, odkomentuj: */
    /* image-rendering: pixelated; */
  }

  /* WZGÓRZE – obrazek zamiast izohips */
  .hill{
    background:
      url('battle_images/hills.png') center / 100% 100% no-repeat;
    box-shadow: inset 0 0 0 1px #0004;
    /* image-rendering: pixelated; */ /* opcjonalnie */
  }

  .water{background:linear-gradient(135deg,#0a3a6e,#041e3a)}

  .selected{ outline:3px solid #fff8; box-shadow:0 0 0 2px #fff3 inset,0 8px 16px #000a; }
  .unit .letter{ font-size:16px; text-shadow:0 1px 0 #000a, 0 0 6px #0008; }

  /* --- SPRITE zamiast pionka --- */
  .unit-sprite{
    position:relative; z-index:2;
    width:calc(var(--cell)*1.2);
    height:calc(var(--cell)*1.2);
    display:flex; align-items:center; justify-content:center;
    cursor:pointer; user-select:none;
    filter: drop-shadow(0 10px 24px #000a);
    border-radius:10px; /* dla ramki zaznaczenia */
  }
  .unit-sprite img.unit-img{
    width:100%; height:100%; object-fit:contain; image-rendering: crisp-edges;
  }
  /* zaznaczenie */
  .unit-sprite.selected{ outline:3px solid #fff7; }

  /* odznaki jak wcześniej */
  .unit-sprite .flag{
    position:absolute; top:-2px; left:10px; width:0; height:0;
    border-left:10px solid #f0f2ff; border-top:6px solid transparent; border-bottom:6px solid transparent;
    filter:drop-shadow(0 1px 0 #000a);
  }
  .unit-sprite .hits{
    position:absolute; bottom:-2px; right:10px; font-size:11px; font-weight:900; opacity:.95;
    color:#fff; text-shadow:0 1px 0 #000;
  }

  .docdesc{
    margin:6px 0 0;
    background:#0e1330;
    border:1px solid #313867;
    border-radius:10px;
    padding:8px 10px;
    font-size:12px; line-height:1.35; opacity:.95;
  }


  /* Odznaki */
  .flag{ position:absolute; top:2px; left:2px; width:0; height:0; border-left:10px solid #ddd; border-top:6px solid transparent; border-bottom:6px solid transparent; filter:drop-shadow(0 1px 0 #000a); }
  .hits{ position:absolute; bottom:2px; right:4px; font-size:11px; font-weight:900; text-shadow:0 1px 0 #000; opacity:.9 }

  /* Panele/UI */
  .side{width:700px;background:var(--panel);border-radius:12px;padding:14px;box-shadow:0 8px 30px #0007}
  .sec{margin-bottom:14px} .sec h3{margin:0 0 8px;font-size:15px;letter-spacing:.2px}
  .row{display:flex;gap:8px;align-items:center;margin-bottom:8px;flex-wrap:wrap}
  select,input[type=text],button{background:#0e1330;color:var(--text);border:1px solid #313867;border-radius:10px;padding:8px 10px}
  button{background:#1f2760;border-color:#4250a9;cursor:pointer;font-weight:600} button:hover{filter:brightness(1.1)}
  .log{height:320px;overflow:auto;background:#0b0f26;border:1px solid #2b335f;border-radius:10px;padding:10px;white-space:pre-wrap}
  .legend{font-size:12px;opacity:.8}
  .toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .sep{flex:1 1 auto}
  .tag{padding:2px 8px;border-radius:8px;background:#0e1330;border:1px solid #313867}
  .pill{padding:2px 8px;border-radius:999px;background:#0e1330;border:1px solid #313867; font-size:12px}
  
  .stepper { display:flex; align-items:center; gap:8px; }
  .stepper .gap { width:16px; }
  .stepper-label { opacity:.85; margin-right:4px; }
  .btn-step{
    width:28px; height:28px; line-height:26px; padding:0;
    display:inline-flex; align-items:center; justify-content:center;
    border-radius:8px; border:1px solid #4250a9; background:#1f2760; font-weight:900;
  }
  .stepper-val{
    min-width:22px; text-align:center; font-weight:800; display:inline-block;
  }
  
    /* Sprite: zaznaczenie pozostaje jak było */
  .unit-sprite.selected{
    outline:3px solid #fff7;
  }

  /* Ucieczka: mocna przezroczystość + lekkie odbarwienie */
  .unit-sprite.routed img.unit-img{
    opacity:.5;
    filter:grayscale(.35) saturate(.7) contrast(.9);
    transition:opacity .2s ease, filter .2s ease;
  }

  /* Trafiony: delikatnie „podkręcony” kolor */
  .unit-sprite.bloodied img.unit-img{
    filter:saturate(1.2) contrast(1.05);
  }

  /* Obramówki na kaflu w zależności od stanu jednostki */
  .cell{ position:relative; }
  .cell.bloodied-cell{
    outline:3px solid #ffd400;   /* żółta ramka */
    outline-offset:2px;
  }
  .cell.routed-cell{
    outline:3px solid #ffffff;   /* biała ramka */
    outline-offset:2px;
  }
  
  /* „Zwłoki” jednostki – leżą pod aktywnymi żetonami */
  .corpse-sprite{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%, -50%);
    width:calc(var(--cell)*0.72);
    height:calc(var(--cell)*0.72);
    pointer-events:none;      /* nie łapie klików */
    z-index:1;                /* pod aktywnym żetonem (ten ma z-index:2) */
  }
  .corpse-sprite img.unit-img{
    width:100%; height:100%; object-fit:contain;
    opacity:.7;               /* 50% jak chciałeś */
    filter:grayscale(.3) saturate(.8) contrast(.95);
  }
    
</style>
</head>
<body>
<div class="wrap">
  <div class="board-wrap">
    <div class="toolbar">
      <strong>Mikro-krok: <span id="step">0</span></strong>
      <span>• Pogoda:</span>
      <select id="weather">
        <option value="pogodnie">pogodnie</option>
        <option value="deszcz">deszcz</option>
        <option value="bloto">błoto</option>
      </select>
      <span>• Seed:</span><input id="seed" value="123" style="width:80px"/>
      <button id="btnStart">Start</button>
      <button id="btnReset">Reset</button>
      <label><input type="checkbox" id="placeMode" checked/> Tryb rozmieszczania</label>
    </div>
    <div class="toolbar">
      <span class="tag">Doktryna A:</span><select id="doctrineA"></select>
      <span class="tag">Doktryna O:</span><select id="doctrineO"></select>
      <button id="btnAutoPlace">Auto-rozmieszczenie</button>
      <button id="btnRandomMap">Losuj mapę</button>
      <span class="sep"></span>
      <button id="btnStep">Krok mikro</button>
      <button id="btnToAuto">Do autokońca</button>
      <button id="btnFinish">Koniec</button>
    </div>
    <div id="board" class="board"></div>
  </div>

  <div class="side">
    <div class="sec">
      <h3>Skład armii</h3>

      <!-- ATAKUJĄCY -->
      <div class="row">
        <label style="min-width:90px">Atakujący:</label>
        <div class="stepper" data-side="A">
          <span class="stepper-label">P:</span>
          <button class="btn-step" data-type="P" data-delta="-1">−</button>
          <span class="stepper-val" id="A-P">2</span>
          <button class="btn-step" data-type="P" data-delta="1">+</button>
          <span class="gap"></span>
          <span class="stepper-label">K:</span>
          <button class="btn-step" data-type="K" data-delta="-1">−</button>
          <span class="stepper-val" id="A-K">1</span>
          <button class="btn-step" data-type="K" data-delta="1">+</button>
        </div>
      </div>

      <!-- OBRONCA -->
      <div class="row">
        <label style="min-width:90px">Obrońca:</label>
        <div class="stepper" data-side="O">
          <span class="stepper-label">P:</span>
          <button class="btn-step" data-type="P" data-delta="-1">−</button>
          <span class="stepper-val" id="O-P">2</span>
          <button class="btn-step" data-type="P" data-delta="1">+</button>
          <span class="gap"></span>
          <span class="stepper-label">K:</span>
          <button class="btn-step" data-type="K" data-delta="-1">−</button>
          <span class="stepper-val" id="O-K">1</span>
          <button class="btn-step" data-type="K" data-delta="1">+</button>
        </div>
      </div>

      <div class="row">
        <button id="btnApplyArmy">Zastosuj składy</button>
      </div>
    </div>

    <div class="sec" id="editBox" style="display:none">
      <h3>Edycja zaznaczonej jednostki</h3>
      <div class="row"><div>Jednostka:</div><div id="selInfo" class="pill">—</div></div>
      <div class="row">
        <label>Formacja:</label>
        <select id="selFormation"></select>
        <button id="btnApplyFormation">Zmień</button>
      </div>
    </div>

    <div class="sec"><h3>Log</h3><div id="log" class="log"></div></div>
    <div class="sec legend">
      <div><strong>Koniec gry:</strong> kliknij <em>Koniec</em> albo nastąpi auto, gdy jedna strona nie ma już zdolnych do walki (wszyscy zabici lub w ucieczce).</div>
      <div><strong>Kontakt:</strong> sąsiadujące (N/S/E/W) wrogie żetony walczą od razu i nie ruszają się w tym kroku.</div>
      <div><strong>Strefa bitwy:</strong> kol. 2–7; normalny ruch nie wychodzi poza tę strefę. Uciekinierzy mogą cofać się do kol. 1/8 i dopiero poza planszę „uciekają”.</div>
    </div>
  </div>
</div>

<script>
/* ===== Parametry planszy ===== */
const ROWS = ["X","A","B","C","Y"];      // X = bufor ponad, Y = bufor poniżej
const SETUP_ROWS = ["A","B","C"];        // tylko tu wolno rozstawiać

const COLS=[1,2,3,4,5,6,7,8];
const BTL_MIN=2, BTL_MAX=7; // strefa bitwy = 2..7
const ORIENT={A:+1,O:-1};

const Terrain = { PLAIN:'.', FOREST:'L', HILL:'W', WATER:'~' };

const Orders = {
  UTRZYMAJ: 'UTRZYMAJ',
  SZARZA: 'SZARZA',
  SKOS_L: 'SKOS_L',
  SKOS_P: 'SKOS_P',
  PION_GORA: 'PION_GORA',   // NOWE
  PION_DOL:  'PION_DOL'     // NOWE
};


const Weather={POGODNIE:'pogodnie',DESZCZ:'deszcz',BLOTO:'bloto'};
const clamp=(v,min,max)=>Math.max(min,Math.min(max,v)), rIdx=r=>ROWS.indexOf(r), stepRow=(r,d)=>ROWS[rIdx(r)+d]||null, d6=()=>1+Math.floor(Math.random()*10);

class Unit{
  constructor(side,type,num){
    this.side=side; this.type=type; this.num=num;
    this.row=null; this.col=null;
    this.order=Orders.UTRZYMAJ; this.flankGuard=false;
    this.hits=0; this.routed=false; this.bloodied=false; this.dead=false; this.escaped=false;
    this.didKill=false;
    this._lastFacing = (side === 'A' ? +1 : -1); // +1 = prawo, -1 = lewo

    this.formation = (type==='P~'?'SZACH' : type==='P□'?'CZWOR' : (type[0]==='K'?'KLIN':'LINIA'));

    // NOWE: klin – bonus przy pierwszym ataku
    this._wedgeFirstAttackDone = false;
  }

  setTypeAndFormation(t){
    const prev = this.formation;           // NOWE
    this.type=t;
    this.formation = (t==='P~'?'SZACH' : t==='P□'?'CZWOR' : (t[0]==='K'?'KLIN':'LINIA'));

    // NOWE: jeśli przechodzimy na KLIN z innej formacji, zresetuj „pierwszy atak”
    if (this.formation==='KLIN' && prev!=='KLIN'){
      this._wedgeFirstAttackDone = false;
    }
  }
}


/* ===== Pomoc diagnostyczna dla ruchu ===== */
const cellStr = (r,c)=> `${r}${c}`;
const unitKey = (u) => `${u.side}:${u.type}:${u.num}`; // np. "A:K:1", "O:P□:2"

function whyBlocked(G, u, t, {respectBattleZone=true} = {}){
  if (!t || !t.row)         return { blocked:true, reason:'brak kafla (krawędź planszy)' };
  if (t.col < COLS[0] || t.col > COLS[COLS.length-1])
                           return { blocked:true, reason:'poza planszą' };
  if (respectBattleZone && (t.col < BTL_MIN || t.col > BTL_MAX))
                           return { blocked:true, reason:'poza strefą bitwy (2–7)' };
  if (G.map[t.row][t.col] === Terrain.WATER)
                           return { blocked:true, reason:`woda na ${cellStr(t.row,t.col)}` };
	const ally = G.unitAt(t.row, t.col);
	if (ally && ally === u) return { blocked:false, reason:'' }; // to jest ten sam żeton
  if (ally && ally.side === u.side && !ally.dead && !ally.escaped)
                           return { blocked:true, reason:`sojusznik na ${cellStr(t.row,t.col)}` };
  const foe  = G.enemyAt(t.row, t.col, u.side);
  if (foe)                  return { blocked:true, reason:`wróg na ${cellStr(t.row,t.col)} (walka tylko w fazie 0)` };
  return { blocked:false, reason:'' };
}


class Game{
  constructor(){
    this.map=this.emptyMap(); this.units=[];
    this.weather=Weather.POGODNIE; this.step=0;
    this.finished=false; this.endMsg='';
    this.firstContactStep = null;   // ← NOWE
  }
  emptyMap(){ const m={}; ROWS.forEach(r=>{ m[r]={}; COLS.forEach(c=> m[r][c]=Terrain.PLAIN ); }); return m; }
randomMap(seed=123){
  const R=()=>Math.random();
  this.map=this.emptyMap();

  // Woda tylko poza rzędami rozstawienia (A/B/C), w strefie bitwy 2–7
  const waterRows = ROWS.filter(r => !SETUP_ROWS.includes(r));
  if (R()<0.35 && waterRows.length){
    const rr = waterRows[Math.floor(R()*waterRows.length)];
    const sc = 4 + Math.floor(R()*2); // 4..5 — start mniej więcej w środku
    for(let c=sc;c<=BTL_MAX;c++) this.map[rr][c]=Terrain.WATER;
    // (brak brodu)
  }

  // Lasy
  for(let i=0,n=1+Math.floor(R()*3); i<n; i++){
    const r=ROWS[Math.floor(R()*ROWS.length)];
    const c=BTL_MIN+Math.floor(R()*(BTL_MAX-BTL_MIN+1));
    this.map[r][c]=Terrain.FOREST;
    if (c<BTL_MAX && R()<0.6) this.map[r][c+1]=Terrain.FOREST;
  }

  // Wzgórza
  for(let i=0,n=1+Math.floor(R()*2); i<n; i++){
    const r=ROWS[Math.floor(R()*ROWS.length)];
    const c=2+Math.floor(R()*5);
    const cc=clamp(c, BTL_MIN, BTL_MAX);
    this.map[r][cc]=Terrain.HILL;
  }
}

  
	advanceDir(u){
	  // Domyślny kierunek (A: +1, O: -1)
	  const def = ORIENT[u.side];

	  // Bierzemy pod uwagę tylko zdolnych do walki wrogów (ignoruj routed/escaped/dead)
	  const foes = this.units.filter(x =>
		!x.dead && !x.escaped && !x.routed && x.side !== u.side
	  );

	  if (!foes.length) return def;

	  // Czy ktoś jest "z przodu" względem domyślnego kierunku?
	  const anyForward  = foes.some(f => def === +1 ? (f.col >= u.col) : (f.col <= u.col));
	  // Czy ktoś jest "z tyłu"?
	  const anyBackward = foes.some(f => def === +1 ? (f.col <  u.col) : (f.col >  u.col));

	  // Jeśli z przodu brak, a z tyłu są — zawróć
	  if (!anyForward && anyBackward) return -def;

	  return def;
	}


  start({attacker=["K","P","P"],defender=["P~","P","K"],weather='pogodnie',seed=123}={}){
    this.weather=weather; this.step=0; this.finished=false; this.endMsg=''; this.units=[]; this.randomMap(seed);
    const addSide=(s,arr)=>{ let p=0,k=0; arr.forEach(t=>{ let type=(t==='P~'||t==='P□')?t:t.toUpperCase(); if (type==='P[]'||type==='P#') type='P□'; const n=type[0]==='K'? ++k : ++p; this.units.push(new Unit(s,type,n)); }); };
    addSide('A',attacker); addSide('O',defender); this.autoPlaceAll();
    this.firstContactStep = null;   // ← RESET
  }
  clearPositions(){ this.units.forEach(u=>{ if(!u.dead && !u.escaped){ u.row=null; u.col=null; } }); }
  autoPlace(side){
    const cols=side==='A'?[2,3]:[7,6]; // rozmieszczenie w strefie bitwy
    const slots=[]; for(const c of cols){ for(const r of SETUP_ROWS) slots.push([r,c]); }
    let i=0; this.units.filter(u=>u.side===side&&!u.dead&&!u.escaped).forEach(u=>{
      let s=null; while(i<slots.length){ const cand=slots[i++]; if(!this.unitAt(cand[0],cand[1])){ s=cand; break; } }
      if(!s) s=slots[slots.length-1]; u.row=s[0]; u.col=s[1];
    });
  }
  autoPlaceAll(){ this.clearPositions(); this.autoPlace('A'); this.autoPlace('O'); }
  unitAt(r,c){ return this.units.find(u=>!u.dead && !u.escaped && u.row===r && u.col===c); }
  enemyAt(r,c,side){ return this.units.find(u=>!u.dead && !u.escaped && u.row===r && u.col===c && u.side!==side); }

  setOrder(u, ord){
    if (u.routed || u.dead || u.escaped) return;
    u.order = ord;
    u.flankGuard = false; // już nie używamy specjalnej flagi
  }


  adjEnemies(u){
    if (u.routed) return []; // jednostka w ucieczce nie walczy
    const n=[[0,1],[0,-1],[-1,0],[1,0]];
    const out=[];
    for(const [dr,dc] of n){
      const rr=ROWS[rIdx(u.row)+dr]; const cc=u.col+dc;
      if(!rr||cc<COLS[0]||cc>COLS[COLS.length-1]) continue;
      const e=this.enemyAt(rr,cc,u.side);
      if(e && !e.routed) out.push(e); // <- pomiń uciekających
    }
    return out;
  }

  registerHit(victim, log){
    victim.hits++;
    if (victim.hits>=2){
      victim.dead=true;
      log(`   ✖ ${victim.type[0]}${victim.num}(${victim.side}) GINIE (2. trafienie).`);
      return;
    }
    const flee = Math.random()<0.5;
    if (flee){ victim.routed=true; victim.bloodied=false; log(`   ⚑ ${victim.type[0]}${victim.num}(${victim.side}) U-C-I-E-K-A (załamanie szyku).`); }
    else { victim.bloodied=true; victim.routed=false; log(`   ✚ ${victim.type[0]}${victim.num}(${victim.side}) POZOSTAJE (krwawi).`); }
  }

	/* ===== Walka z modyfikatorami ===== */
	combat(u1, u2, ctx, log){
	  if (u1.dead||u2.dead||u1.escaped||u2.escaped) return;
	  if (u1.routed||u2.routed) return;

	  // Progi bazowe i „notatniki” modyfikatorów (osobno dla każdej jednostki)
	  let need1 = 8, need2 = 8;
	  const m1 = [], m2 = [];

	  // Skróty
	  const isCav1 = u1.type[0] === 'K', isCav2 = u2.type[0] === 'K';
	  const isInf1 = u1.type[0] === 'P', isInf2 = u2.type[0] === 'P';
	  const ter1 = this.map[u1.row][u1.col];
	  const ter2 = this.map[u2.row][u2.col];

	  const from1 = (ctx && ctx.from1) ? ctx.from1 : { row:u1.row, col:u1.col };
	  const from2 = (ctx && ctx.from2) ? ctx.from2 : { row:u2.row, col:u2.col };

	  // tylko FRONTALNOŚĆ (na potrzeby szarży/hill/ford)
	  const frontal12 = isFrontalFrom(u1, u2, from1);
	  const frontal21 = isFrontalFrom(u2, u1, from2);

	  const offensive = (u, opp, frontal) =>
		(u.order === Orders.SZARZA) && frontal; // „ofensywny” = SZARŻA + kontakt frontalny

    const cavPenalty = (ter) => {
      let pen = 0;
      if (ter === 'L') pen = Math.max(pen, 2); // las spowalnia K
      if (this.weather === Weather.BLOTO) pen = Math.max(pen, 2);
      else if (this.weather === Weather.DESZCZ) pen = Math.max(pen, 1);
      return pen;
    };

	  if (isCav1){ const p = cavPenalty(ter1); if (p){ need1 += p; m1.push(`+${p} kawaleria w ${nameTer(ter1)} / pogoda`); } }
	  if (isCav2){ const p = cavPenalty(ter2); if (p){ need2 += p; m2.push(`+${p} kawaleria w ${nameTer(ter2)} / pogoda`); } }

	  // Szarża kawalerii (per jednostka; frontalnie; na równinie; pogodnie)
	  if (isCav1 && offensive(u1, u2, frontal12) && ter2 === '.' && this.weather === Weather.POGODNIE) {
		need1--; m1.push('−1 kawaleria: szarża na równinie (pogodnie)');
	  }
	  if (isCav2 && offensive(u2, u1, frontal21) && ter1 === '.' && this.weather === Weather.POGODNIE) {
		need2--; m2.push('−1 kawaleria: szarża na równinie (pogodnie)');
	  }

	// Wzgórze
	if (ter1 === 'W' && frontal21) { need1--; m1.push('−1 obrona na wzgórzu'); need2++; m2.push('+1 atak pod górę'); }
	if (ter2 === 'W' && frontal12) { need2--; m2.push('−1 obrona na wzgórzu'); need1++; m1.push('+1 atak pod górę'); }

	// Bród (tylko piechota, i tylko gdy NIE ma SZARŻA)
	if (ter1 === '=' && isInf1 && frontal21 && u1.order !== Orders.SZARZA) {
	  need1 -= 2; m1.push('−2 piechota: obrona na brodzie');
	  need2 += 1; m2.push('+1 atak na brodzie (przeciw piechocie)');
	}
	if (ter2 === '=' && isInf2 && frontal12 && u2.order !== Orders.SZARZA) {
	  need2 -= 2; m2.push('−2 piechota: obrona na brodzie');
	  need1 += 1; m1.push('+1 atak na brodzie (przeciw piechocie)');
	}


	  // P~ w lesie: obrońca stojący w lesie −1; atakujący wchodzący w las −1
	  if (u1.type === 'P~' && ter1 === 'L') { need1--; m1.push('−1 piechota-szach w lesie (obrona)'); }
	  if (u1.type === 'P~' && this.map[u2.row][u2.col] === 'L' && frontal12) { need1--; m1.push('−1 piechota-szach idzie w las'); }
	  if (u2.type === 'P~' && ter2 === 'L') { need2--; m2.push('−1 piechota-szach w lesie (obrona)'); }
	  if (u2.type === 'P~' && this.map[u1.row][u1.col] === 'L' && frontal21) { need2--; m2.push('−1 piechota-szach idzie w las'); }

	  // P□ broni się lepiej vs kawaleria
	  if (u1.type === 'P□' && isCav2) { need1--; m1.push('−1 czworobok vs kawaleria'); }
	  if (u2.type === 'P□' && isCav1) { need2--; m2.push('−1 czworobok vs kawaleria'); }


	  const adjFoes1 = this.adjEnemies(u1).filter(x => !x.routed);
	  const adjFoes2 = this.adjEnemies(u2).filter(x => !x.routed);
	  if (adjFoes1.length >= 2) { need1 += 2; m1.push('+2 okrążenie'); need2--; m2.push('−1 okrążenie'); }
	  if (adjFoes2.length >= 2) { need2 += 2; m2.push('+2 okrążenie'); need1--; m1.push('−1 okrążenie'); }


	  // KLIN (u1)
	  if (u1.formation === 'KLIN') {
		if (offensive(u1, u2, frontal12)) {
		  if (!u1._wedgeFirstAttackDone) {
			need1 -= 3; m1.push('−3 klin: pierwszy atak (tylko przy SZARŻY)');
			u1._wedgeFirstAttackDone = true; // zużywamy tylko przy realnej szarży
		  } else {
			need1 += 1; m1.push('+1 klin: kolejne starcia (ofensywa)');
		  }
		} else {
		  need1 += 1; m1.push('+1 klin: słaba obrona'); // obrona zawsze +1, bez zużycia
		}
	  }

	  // KLIN (u2)
	  if (u2.formation === 'KLIN') {
		if (offensive(u2, u1, frontal21)) {
		  if (!u2._wedgeFirstAttackDone) {
			need2 -= 3; m2.push('−3 klin: pierwszy atak (tylko przy SZARŻY)');
			u2._wedgeFirstAttackDone = true;
		  } else {
			need2 += 1; m2.push('+1 klin: kolejne starcia (ofensywa)');
		  }
		} else {
		  need2 += 1; m2.push('+1 klin: słaba obrona');
		}
	  }


	// Pomocniki do rozpoznawania piechoty/kawalerii w liniach
	const isInfLine   = u => u.formation === 'LINIA' && u.type[0] === 'P';
	const isInfSquare = u => u.formation === 'CZWOR' && u.type[0] === 'P';
	const isInfSzach  = u => u.formation === 'SZACH'  && u.type[0] === 'P';

	// KARA tylko w starciu z LINIĄ PIECHOTY (P w LINIA).
	// LINIA KAWALERII (K w LINIA) NIE uruchamia kary.

	// Strona ①: P□ / P~ kontra linia piechoty (po stronie ②)
	if ((isInfSquare(u1) || isInfSzach(u1)) && isInfLine(u2)) {
	  need1 += 1;
	  m1.push('+1 (czworobok/szachownica piechoty vs linia piechoty)');
	}

	// Strona ②: P□ / P~ kontra linia piechoty (po stronie ①)
	if ((isInfSquare(u2) || isInfSzach(u2)) && isInfLine(u1)) {
	  need2 += 1;
	  m2.push('+1 (czworobok/szachownica piechoty vs linia piechoty)');
	}


	  // Przytnij progi do 2..10
	  need1 = clamp(need1, 2, 10);
	  need2 = clamp(need2, 2, 10);

	  // Rzuty (k10) i log
	  const r1 = d6(), r2 = d6();
	  const hit1 = r1 >= need1 && !u1.didKill;
	  const hit2 = r2 >= need2 && !u2.didKill;

	  log(`Starcie ${u1.type[0]}${u1.num}(${u1.side}) ⇄ ${u2.type[0]}${u2.num}(${u2.side})`);
	  log(`  ①: potrzeba ≥${need1} [${m1.length?m1.join('; '):'brak modyf.'}] | rzut=${r1}`);
	  log(`  ②: potrzeba ≥${need2} [${m2.length?m2.join('; '):'brak modyf.'}] | rzut=${r2}`);

	  if      (hit1 && hit2) log(`  → WYNIK: OBIE strony trafione.`);
	  else if (hit1)         log(`  → WYNIK: strona ① trafiła | ② pudłuje.`);
	  else if (hit2)         log(`  → WYNIK: strona ② trafiła | ① pudłuje.`);
	  else                   log(`  → WYNIK: nikt nie trafił.`);

	  if (hit1){ this.registerHit(u2, log); u1.didKill=true; }
	  if (hit2){ this.registerHit(u1, log); u2.didKill=true; }
	}


  isFlank(att,def,ctx){ const dr=rIdx(ctx.from.row)-rIdx(def.row), dc=ctx.from.col-def.col; const back=(ORIENT[def.side]===+1? dc<0: dc>0); return dr!==0 || back; }
  isFrontal(att,def){ const dc=att.col-def.col; return (ORIENT[def.side]===+1 ? dc<0 : dc>0); }

  /* ===== Ruch ===== */
  tryMove(u, r,c, {respectBattleZone=true}={}){
    if(!r) return false;
    if (c<COLS[0] || c>COLS[COLS.length-1]) return false;
    if (respectBattleZone && (c<BTL_MIN || c>BTL_MAX)) return false; // normalny ruch nie wychodzi poza 2..7
    const t=this.map[r][c]; if (t==='~') return false;
    if (this.unitAt(r,c)) return false;
    const prevRow = u.row, prevCol = u.col;
    if (this.unitAt(r,c)) return false;

    const dx = c - prevCol;
    if (dx !== 0) {
      u._lastFacing = (dx > 0 ? +1 : -1);   // prawo / lewo
    }
    
    u.row = r; 
    u.col = c; 
    return true;
  }

  /* ===== UCIECZKA: A zawsze LEWO, O zawsze PRAWO ===== */
  retreatStep(u){
    // docelowa krawędź: A -> kol. 1 (lewo), O -> kol. 8 (prawo)
    const edgeCol = (u.side === 'A') ? COLS[0] : COLS[COLS.length-1];
    const stepH   = (edgeCol < u.col) ? -1 : +1; // kierunek poziomy w stronę krawędzi

    // kandydaci ruchu w jednej mikro–ucieczce (priorytet: bok -> skosy -> piony)
    const primary   = { r: u.row,                 c: u.col + stepH };              // w bok do krawędzi
    const diagUp    = { r: stepRow(u.row, -1),    c: u.col + stepH };              // skos (góra) w stronę krawędzi
    const diagDown  = { r: stepRow(u.row, +1),    c: u.col + stepH };              // skos (dół)  w stronę krawędzi
    const upOnly    = { r: stepRow(u.row, -1),    c: u.col };                      // pion w górę (gdy poziom zablok.)
    const downOnly  = { r: stepRow(u.row, +1),    c: u.col };                      // pion w dół  (gdy poziom zablok.)

    const tries = [primary, diagUp, diagDown, upOnly, downOnly].filter(t => t.r);

    for (const t of tries){
      // zejście poza planszę w kierunku krawędzi = sukces ucieczki
      if (t.c < COLS[0] || t.c > COLS[COLS.length-1]) { u.escaped = true; return; }
      // podczas ucieczki ignorujemy strefę bitwy (respectBattleZone:false)
      if (this.tryMove(u, t.r, t.c, {respectBattleZone:false})) return;
    }
    // jeśli wszystko zablokowane – jednostka zostaje (spanikowana) na miejscu w tej mikro–turze
  }



  /* ===== Koniec + podsumowanie ===== */
  computeSummary(reason=''){
    const stats = (side)=>({
      dead: this.units.filter(u=>u.side===side && u.dead).length,
      escaped: this.units.filter(u=>u.side===side && u.escaped).length,
      routed: this.units.filter(u=>u.side===side && !u.dead && !u.escaped && u.routed).length,
      bloodied: this.units.filter(u=>u.side===side && !u.dead && !u.escaped && u.bloodied && !u.routed).length,
      active: this.units.filter(u=>u.side===side && !u.dead && !u.escaped && !u.routed).length,
      onField: this.units.filter(u=>u.side===side && !u.dead && !u.escaped).length
    });
    const A=stats('A'), O=stats('O');
    let winner='—';
    if (A.active===0 && O.active>0) winner='O';
    else if (O.active===0 && A.active>0) winner='A';
    else if (A.dead+A.escaped !== O.dead+O.escaped) winner = (A.dead+A.escaped < O.dead+O.escaped) ? 'A' : 'O';

    return `KONIEC${reason?`: ${reason}`:''}
Zwycięzca: ${winner==='—'?'brak (remis)':(winner==='A'?'Atakujący':'Obrońca')}

Atakujący (A):
  Zabici: ${A.dead} | Uciekli: ${A.escaped} | Zdolni do walki: ${A.active}
  Na polu (wszyscy nie-zabici): ${A.onField} | W ucieczce na polu: ${A.routed} | Krwawi (ale walczą): ${A.bloodied}

Obrońca (O):
  Zabici: ${O.dead} | Uciekli: ${O.escaped} | Zdolni do walki: ${O.active}
  Na polu (wszyscy nie-zabici): ${O.onField} | W ucieczce na polu: ${O.routed} | Krwawi (ale walczą): ${O.bloodied}`;
  }

  finish(reason='(na żądanie)'){ if (this.finished) return; this.finished = true; this.endMsg = this.computeSummary(reason); }

  autoFinishIfNoActives(){
    const aActive = this.units.some(u=>u.side==='A' && !u.dead && !u.escaped && !u.routed);
    const oActive = this.units.some(u=>u.side==='O' && !u.dead && !u.escaped && !u.routed);
    if (!aActive || !oActive){
      this.finished = true;
      const side = !aActive && oActive ? 'A' : (!oActive && aActive ? 'O' : '—');
      this.endMsg = this.computeSummary(side==='—'?'obie strony bez aktywnych':'armia '+side+' nie ma już zdolnych do walki');
      return true;
    }
    return false;
  }

  /* ===== Silnik kroku ===== */
  doOneMicroStep(log){
    if(this.finished) return true;
    this.units.forEach(u=>{u.didKill=false;});

    const stepNo = this.step + 1;
    log(`\n─────────────────[ MIKRO-KROK ${stepNo} ]─────────────────`);
    log('0) WALKA W KONTAKCIE');

	// 0) walka w kontakcie
	const engaged = new Set();
	const pairs = [];

	for (const u of this.units.filter(x => !x.dead && !x.escaped && !x.routed)) {
	  const adj = this.adjEnemies(u);
	  for (const e of adj) {
		const key = [unitKey(u), unitKey(e)].sort().join('|'); // unikalny klucz pary
		if (!pairs.find(p => p.key === key)) pairs.push({ a: u, b: e, key });
	  }
	}

	// zaznacz uczestników kontaktu
	for (const { a, b } of pairs) {
	  engaged.add(unitKey(a));
	  engaged.add(unitKey(b));
	}

	// rozdziel pary na frontalne i pozostałe
	const frontalPairs = [];
	const nonFrontalPairs = [];
	for (const { a, b, key } of pairs) {
	  // „frontalne” = obie strony mają kontakt od frontu względem orientacji przeciwnika
	  const abFront = this.isFrontal(a, b);
	  const baFront = this.isFrontal(b, a);
	  if (abFront && baFront) frontalPairs.push({ a, b, key });
	  else nonFrontalPairs.push({ a, b, key });
	}

	// jeśli są frontalne – rozgrywamy tylko je; w przeciwnym razie rozgrywamy flankowe
	const toResolve = frontalPairs.length > 0 ? frontalPairs : nonFrontalPairs;

  if (this.firstContactStep == null && toResolve.length > 0){
    this.firstContactStep = this.step;   
  }

	if (frontalPairs.length > 0 && nonFrontalPairs.length > 0) {
	  log(`(priorytet: ${frontalPairs.length} starć FRONTALNYCH; pozostałe w kontakcie czekają)`);
	}

	for (const { a, b } of toResolve) {
	  log(`(kontakt: ${a.type[0]}${a.num} z ${b.type[0]}${b.num})`);
		this.combat(a, b, {
		  from1: { row: a.row, col: a.col },
		  from2: { row: b.row, col: b.col }
		}, log);

	  if (this.finished) { log(this.endMsg); return true; }
	}


    // 1) Uciekinierzy
    log('1) UCIECZKI');
    this.units.filter(u=>!u.dead && !u.escaped && u.routed).forEach(u=> this.retreatStep(u));

	// 2) RUCH (bez nowych starć)
	log('2) RUCH (bez nowych starć)');

	this.units
	  .filter(u => !u.dead && !u.escaped)
	  .forEach(u => {
		if (u.routed){
		  log(`(stoi ${u.type[0]}${u.num}(${u.side}): w ucieczce)`);
		} else if (engaged.has(unitKey(u))){
		  log(`(stoi ${u.type[0]}${u.num}(${u.side}): był w kontakcie w tej turze)`);
		} else if (u.order === Orders.UTRZYMAJ){
		  log(`(stoi ${u.type[0]}${u.num}(${u.side}): rozkaz UTRZYMAJ)`);
		}
	  });


  const prio = [Orders.SZARZA, Orders.SKOS_L, Orders.SKOS_P, Orders.PION_GORA, Orders.PION_DOL];

	const canTryMove = (u) =>
	  !u.dead && !u.escaped && !u.routed && !engaged.has(unitKey(u));

	const moved = new Set();
	const markMoved   = (u) => moved.add(unitKey(u));
	const notMovedYet = (u) => !moved.has(unitKey(u));

	const isCav = (u) => u.type[0] === 'K';
	const isInf = (u) => u.type[0] === 'P';


	const runWave = (filterFn, label) => {
	  if (label) log(`(fala ruchu: ${label})`);
	  for (const p of prio) {
		// **opcjonalne sortowanie**: np. numerem (od mniejszych do większych)
		const group = this.units
		  .filter(u => canTryMove(u) && notMovedYet(u) && filterFn(u) && u.order === p)
		  .sort((a,b) => a.num - b.num);

		for (const u of group) {
		  const ok = this.applyMove(u, log);
		  if (ok) markMoved(u);   // oznaczamy jako ruszone TYLKO gdy faktycznie się poruszył
		  if (this.finished) { log(this.endMsg); return true; }
		}
	  }
	  return false;
	};

	// 1) Kawaleria atakującego
	if (runWave(u => u.side==='A' && isCav(u), 'kawaleria A')) return true;
	// 2) Kawaleria obrońcy
	if (runWave(u => u.side==='O' && isCav(u), 'kawaleria O')) return true;
	// 3) Piechota atakującego
	if (runWave(u => u.side==='A' && isInf(u), 'piechota A')) return true;
	// 4) Piechota obrońcy
	if (runWave(u => u.side==='O' && isInf(u), 'piechota O')) return true;
	// 5) Pozostali (druga szansa po „odkorkowaniu”)
	if (runWave(u => true, 'pozostali')) return true;



    // 3) Autokońiec, jeśli brak zdolnych do walki
    if (this.autoFinishIfNoActives()){ return true; }

    this.step++;
    return this.finished;
  }

  distToEnemy(u){ const foes=this.units.filter(x=>!x.dead && !x.escaped && x.side!==u.side); if(!foes.length) return 999;
    return foes.map(f=>Math.abs(rIdx(u.row)-rIdx(f.row))+Math.abs(u.col-f.col)).sort((a,b)=>a-b)[0]; }

  /* ===== RUCH: „głupie” applyMove ===== */
  applyMove(u, log){
    const dir = this.advanceDir(u);

    const tryMoveWithWhy = (target, {respectBattleZone=true}={})=>{
      const info = whyBlocked(this, u, target, {respectBattleZone});
      const from = cellStr(u.row,u.col);
      const to   = target ? cellStr(target.row,target.col) : '—';
      if (info.blocked){
        log(`(brak ruchu ${u.type[0]}${u.num}(${u.side}): ${info.reason})`);
        return false;
      }
      if (this.tryMove(u, target.row, target.col, {respectBattleZone})){
        log(`ruch ${u.type[0]}${u.num}(${u.side}): ${from} → ${to}`);
        // piechota w czworoboku po ruchu staje się linią
        if (u.type[0]==='P' && u.formation==='CZWOR'){ u.setTypeAndFormation('P'); log(`(P${u.num}(${u.side}) z CZWOR do LINIA po ruchu)`); }
        return true;
      }
      log(`(brak ruchu ${u.type[0]}${u.num}(${u.side}): nie można wejść na ${to})`);
      return false;
    };

    const target = (() => {
      switch (u.order){
        case Orders.SZARZA:    return { row: u.row,              col: u.col + dir };
        case Orders.SKOS_L:    return { row: stepRow(u.row, -1), col: u.col + dir };
        case Orders.SKOS_P:    return { row: stepRow(u.row, +1), col: u.col + dir };
        case Orders.PION_GORA: return { row: stepRow(u.row, -1), col: u.col };     // NOWE
        case Orders.PION_DOL:  return { row: stepRow(u.row, +1), col: u.col };     // NOWE
        default:               return null;
      }
    })();


    if (!target || !target.row) { log(`(stoi ${u.type[0]}${u.num}(${u.side}): brak legalnego celu)`); return false; }
    return tryMoveWithWhy(target);
  }
}

function nameTer(t){
  return t==='.' ? 'równina'
       : t==='L' ? 'las'
       : t==='W' ? 'wzgórze'
       :           'woda';
}
// FRONT od strony `from` względem orientacji przeciwnika
// FRONT od strony `from` względem orientacji przeciwnika
// FRONT od strony `from` – zawsze TAK
function isFrontalFrom(att, def, from){
  return true;
}

// FLANK/TYŁ – wyłączamy całkiem
function isFlankFrom(att, def, from){
  return false;
}


/* ===== DOKTRYNY (zaktualizowane opisy; tylko 3 rozkazy) ===== */
const DOCTRINES = [
  // OFENSYWNE
  { id:'D1', name:'Przebicie Centrum (ofensywna)',
    desc:'Faza 1: wszyscy idą linią i atakują. Po pierwszym kontakcie cała armia zbiega do dynamicznie wyliczonego rzędu centrum; jednostki w centrum szarżują, reszta skosem dąży dołączać do centrum.' },

  { id:'D2', name:'Sierp na Skrzydłach (ofensywna)',
    desc:'Najpierw wszyscy atakują frontalnie (SZARŻA). Tuż przed kontaktem jednostki skrzydłowe przechodzą na SKOS i próbują obejść, dążąc do lokalnych starć 2-na-1.' },

  { id:'D3', name:'Frontalny atak',
    desc:'Każda jednostka wybiera najbliższego wroga i atakuje go bezpośrednio. Jeśli diagonalny krok skraca dystans lepiej niż frontalny – używa SKOS, w przeciwnym razie SZARŻA.' },

  { id:'D4', name:'Forteca Liniowa (statyczna)',
    desc:'Obrona pozycyjna: wszystkie jednostki utrzymują pozycje (UTRZYMAJ). Brak manewrów, brak kontrataków.' },

  { id:'D5', name:'Elastyczna Obrona (2-na-1 po kontakcie)',
    desc:'Czeka do pierwszego kontaktu (wszyscy UTRZYMAJ). Po pierwszym kontakcie jednostki niezaangażowane dążą do wsparcia trwających starć (atak 2-na-1); walczący stoją.' },

  { id:'D6', name:'Jeż i Kolce (zwarta po kontakcie)',
    desc:'Do pierwszego kontaktu wszyscy UTRZYMAJ. Po pierwszym kontakcie: kawaleria atakuje najbliższą jednostkę, piechota stara się trzymać jak najbliżej siebie (zacieśnianie szyku) i tylko dostraja rząd skosem.' },


 ];
 
function distCells(r1,c1,r2,c2){ return Math.abs(rIdx(r1)-rIdx(r2)) + Math.abs(c1-c2); }
function nearestEnemyOf(G, u){
  const foes = G.units.filter(e => e.side!==u.side && !e.dead && !e.escaped && !e.routed);
  if (!foes.length) return null;
  foes.sort((a,b)=> distCells(u.row,u.col,a.row,a.col) - distCells(b.row,b.col, u.row,u.col));
  return foes[0];
}

function legalOrdersToward(G, u, target){
  if (!target) return [];
  const dir = ORIENT[u.side];
  const cand = [
    { ord: Orders.SZARZA,    r: u.row,              c: u.col + dir },
    { ord: Orders.SKOS_L,    r: stepRow(u.row,-1),  c: u.col + dir },
    { ord: Orders.SKOS_P,    r: stepRow(u.row,+1),  c: u.col + dir },
    { ord: Orders.PION_GORA, r: stepRow(u.row,-1),  c: u.col        },
    { ord: Orders.PION_DOL,  r: stepRow(u.row,+1),  c: u.col        }
  ].filter(x => x.r);

  const playable = cand.filter(x => {
    // strefa bitwy dla ruchów z kolumną
    if ((x.ord===Orders.SZARZA || x.ord===Orders.SKOS_L || x.ord===Orders.SKOS_P) &&
        (x.c < BTL_MIN || x.c > BTL_MAX)) return false;
    const info = whyBlocked(G, u, {row:x.r, col:x.c}, {respectBattleZone:true});
    return !info.blocked;
  });

  const hereD = distCells(u.row,u.col, target.row,target.col);
  const better = playable.filter(x => distCells(x.r,x.c,target.row,target.col) < hereD);
  return { playable, better };
}


function wouldLeaveBattleZone(u, ord){
  const dir = ORIENT[u.side];
  if (ord===Orders.SZARZA || ord===Orders.SKOS_L || ord===Orders.SKOS_P){
    const nextCol = u.col + dir;
    return (nextCol < BTL_MIN || nextCol > BTL_MAX);
  }
  return false; // pion nie zmienia kolumny
}

function nextOrderToward(G, u, target){
  if (!target) return Orders.UTRZYMAJ;

  const hereD = distCells(u.row,u.col, target.row,target.col);
  const dir   = ORIENT[u.side];

  const cand = [
    { ord: Orders.SZARZA,    r: u.row,              c: u.col + dir },
    { ord: Orders.SKOS_L,    r: stepRow(u.row,-1),  c: u.col + dir },
    { ord: Orders.SKOS_P,    r: stepRow(u.row,+1),  c: u.col + dir },
    { ord: Orders.PION_GORA, r: stepRow(u.row,-1),  c: u.col        }, // NOWE
    { ord: Orders.PION_DOL,  r: stepRow(u.row,+1),  c: u.col        }  // NOWE
  ].filter(x => x.r); // tylko legalne rzędy

  // Odfiltruj te, które wyjechałyby poza 2–7 albo są zablokowane
  const playable = cand.filter(x => {
    if (wouldLeaveBattleZone(u, x.ord)) return false;
    const info = whyBlocked(G, u, {row:x.r, col:x.c}, {respectBattleZone:true});
    return !info.blocked;
  });

  if (!playable.length) return Orders.UTRZYMAJ;

  // 1) Najpierw te, które ZMNIEJSZAJĄ dystans do celu
  const better = playable.filter(x => distCells(x.r, x.c, target.row, target.col) < hereD);
  if (better.length) return better[0].ord;

  // 2) W przeciwnym razie cokolwiek legalnego (np. „dostrojenie” rzędu pionem)
  return playable[0].ord;
}



function preferOrderTowardRow(u, targetRow){
  if (!targetRow) return Orders.SZARZA;
  if (u.row === targetRow) return Orders.SZARZA;
  return (rIdx(targetRow) < rIdx(u.row)) ? Orders.SKOS_L : Orders.SKOS_P;
}
function globalMinOpposingDistance(G){
  let best = Infinity;
  const A = G.units.filter(u=>u.side==='A' && !u.dead && !u.escaped && !u.routed);
  const O = G.units.filter(u=>u.side==='O' && !u.dead && !u.escaped && !u.routed);
  for (const a of A) for (const o of O){
    best = Math.min(best, distCells(a.row,a.col,o.row,o.col));
  }
  return (best===Infinity?99:best);
}

function preferOrderTowardTarget(u, target){
  if (!target) return Orders.SZARZA;
  if (u.row === target.row) return Orders.SZARZA;
  // jeśli trzeba iść „w górę” wiersza → SKOS_L, „w dół” → SKOS_P (z zachowaniem kierunku strony)
  return (rIdx(target.row) < rIdx(u.row)) ? Orders.SKOS_L : Orders.SKOS_P;
}

function nonHoldCount(G, side){
  return G.units.filter(u=>u.side===side && !u.dead && !u.escaped && !u.routed && u.order!==Orders.UTRZYMAJ).length;
}
function everyoneHold(G){
  return nonHoldCount(G,'A')===0 && nonHoldCount(G,'O')===0;
}
function nearestEnemyUnit(G, side){
  const me  = G.units.filter(u=>u.side===side && !u.dead && !u.escaped && !u.routed);
  const foe = G.units.filter(u=>u.side!=='A'&&u.side!=='O'?false: u.side!==side && !u.dead && !u.escaped && !u.routed);
  if (!me.length || !foe.length) return null;
  let best=null, bd=1e9;
  for (const u of me){
    for (const e of foe){
      const d = Math.abs(ROWS.indexOf(u.row)-ROWS.indexOf(e.row)) + Math.abs(u.col-e.col);
      if (d<bd){ bd=d; best=u; }
    }
  }
  return best;
}

function ensureProgress(G, side){
  const cand = G.units.find(u => u.side===side && !u.dead && !u.escaped && !u.routed && u.type[0]==='K')
           || nearestEnemyUnit(G, side);
  if (!cand) return;

  if (cand.row==='A' || cand.row==='C') setOrderSkosEncircle(G, cand);
  else                                   setOrderCharge(G, cand); // zamiast „NAPRZÓD”
}

function ensureProgressPair(G){
  if (everyoneHold(G)){
    // NAJPIERW GRACZ (A)
    ensureProgress(G, 'A');
    // O może nadal stać — o to chodzi w Twojej zasadzie
  }
}


/* ===== Ocena sytuacji + presety rozkazów ===== */
function losses(G, side){
  const dead = G.units.filter(u=>u.side===side && u.dead).length;
  const esc  = G.units.filter(u=>u.side===side && u.escaped).length;
  return dead + esc;
}
function actives(G, side){
  return G.units.filter(u=>u.side===side && !u.dead && !u.escaped && !u.routed).length;
}
function isWinning(G, side){
  const foe = (side==='A'?'O':'A');
  const score = (actives(G,side) - actives(G,foe)) - (losses(G,side) - losses(G,foe));
  return score > 0;
}
function hasCav(G, side){
  return G.units.some(u=>u.side===side && !u.dead && !u.escaped && u.type[0]==='K' && !u.routed);
}

function unitsSide(G, side){ return G.units.filter(u=>u.side===side && !u.dead && !u.escaped && !u.routed); }

function unitsCenter(G, side){
  const ci = currentCenterRowIdx(G);
  return unitsSide(G, side).filter(u => rIdx(u.row) === ci);
}
function unitsFlanks(G, side){
  const ci = currentCenterRowIdx(G);
  return unitsSide(G, side).filter(u => rIdx(u.row) !== ci);
}
function isUpperFlank(G, u){ return rIdx(u.row) < currentCenterRowIdx(G); }  // „wyżej” niż centrum
function isLowerFlank(G, u){ return rIdx(u.row) > currentCenterRowIdx(G); }  // „niżej” niż centrum


function unitsCav(G, side){ return unitsSide(G,side).filter(u=>u.type[0]==='K'); }
function unitsInf(G, side){ return unitsSide(G,side).filter(u=>u.type[0]==='P'); }

function setOrderHold(G,u){ G.setOrder(u, Orders.UTRZYMAJ); }
function setOrderCharge(G,u){ G.setOrder(u, Orders.SZARZA); }

function setOrderSkosTowardRow(G, u, targetRowIdx){
  const ui = rIdx(u.row);
  if (ui < targetRowIdx)      G.setOrder(u, Orders.SKOS_P); // w dół, w stronę centrum
  else if (ui > targetRowIdx) G.setOrder(u, Orders.SKOS_L); // w górę, w stronę centrum
  else                        G.setOrder(u, Orders.SZARZA); // już w rzędzie centrum
}

// „okrążaj” = od centrum NA ZEWNĄTRZ (ułatwia zamknięcie skrzydeł)
function setOrderSkosEncircle(G, u){
  const ci = currentCenterRowIdx(G);
  const ui = rIdx(u.row);
  if (ui <= ci) G.setOrder(u, Orders.SKOS_L);  // powyżej/na centrum: idź jeszcze wyżej
  else          G.setOrder(u, Orders.SKOS_P);  // poniżej centrum: idź jeszcze niżej
}

// Pomocnik: wybierz wroga „najbliżej centrum” (po rzędzie), a przy remisie — najbliższego względem tej jednostki
function targetNearestToCenter(G, u){
  const foes = G.units.filter(x => x.side !== u.side && !x.dead && !x.escaped && !x.routed);
  if (!foes.length) return null;
  const ci = currentCenterRowIdx(G);
  // 1) minimalizujemy |rIdx(f.row) - ci|
  // 2) tie-break: mniejsza odległość do u (Manhattan)
  // 3) tie-break: mniejsza kolumna (stabilność), potem rząd
  foes.sort((f1, f2) => {
    const dRow1 = Math.abs(rIdx(f1.row) - ci);
    const dRow2 = Math.abs(rIdx(f2.row) - ci);
    if (dRow1 !== dRow2) return dRow1 - dRow2;

    const du1 = distCells(u.row, u.col, f1.row, f1.col);
    const du2 = distCells(u.row, u.col, f2.row, f2.col);
    if (du1 !== du2) return du1 - du2;

    if (f1.col !== f2.col) return f1.col - f2.col;
    return rIdx(f1.row) - rIdx(f2.row);
  });
  return foes[0];
}


function isActiveAndFree(G, u){
  return !u.dead && !u.escaped && !u.routed && G.adjEnemies(u).length === 0;
}
function myUnitsActive(G, side){
  return G.units.filter(u => u.side===side && !u.dead && !u.escaped && !u.routed);
}
function edgeUnits(G, side){
  const us = myUnitsActive(G, side);
  if (!us.length) return { top:null, bottom:null };
  let top = us[0], bottom = us[0];
  for (const u of us){
    if (rIdx(u.row) < rIdx(top.row)) top = u;
    if (rIdx(u.row) > rIdx(bottom.row)) bottom = u;
  }
  return { top, bottom };
}
function chargeCreatesContact(G, u){
  if (u.routed || u.dead || u.escaped) return false;
  const dir = ORIENT[u.side];
  const target = { row: u.row, col: u.col + dir };

  // czy w ogóle mogę wejść na pole „naprzód”?
  const info = whyBlocked(G, u, target, {respectBattleZone:true});
  if (info.blocked) return false;

  // czy po wejściu na target będę w kontakcie (N/S/E/W) z kimś z wrogów?
  const neigh = [
    {row: target.row,         col: target.col + 1},
    {row: target.row,         col: target.col - 1},
    {row: stepRow(target.row,-1), col: target.col},
    {row: stepRow(target.row,+1), col: target.col}
  ].filter(p => p.row);

  return neigh.some(p => {
    const foe = G.enemyAt(p.row, p.col, u.side);
    return foe && !foe.routed && !foe.dead && !foe.escaped;
  });
}

function oneGapEnemyAhead(G, u){
  const dir = ORIENT[u.side];
  const mid = { row: u.row, col: u.col + dir };
  const dst = { row: u.row, col: u.col + 2*dir };
  if (!mid.row) return false;
  // w strefie bitwy (dla „przodu”), środkowe pole wolne, a na dst stoi wróg
  if (mid.col < BTL_MIN || mid.col > BTL_MAX) return false;
  if (G.map[mid.row][mid.col] === Terrain.WATER) return false;
  if (G.unitAt(mid.row, mid.col)) return false;
  const e = G.enemyAt(dst.row, dst.col, u.side);
  return !!e;
}
function engagedEnemiesAgainstMySide(G, side){
  const out = new Set();
  for (const u of myUnitsActive(G, side)){
    for (const e of G.adjEnemies(u)) if (!e.routed) out.add(e);
  }
  return Array.from(out);
}
function chooseOrderToward(G, u, target){
  // twarde „no-touch” dla routed/dead/escaped
  if (u.routed || u.dead || u.escaped) return Orders.UTRZYMAJ;
  // preferujemy ruch, który skraca dystans; jeśli żaden nie skraca — cokolwiek legalnego
  const { better, playable } = legalOrdersToward(G, u, target);
  if (better.length) return better[0].ord;
  if (playable.length) {
    // wybierz ten, który MINIMALIZUJE dystans po ruchu
    const best = playable
      .map(x => ({ord:x.ord, d: distCells(x.r, x.c, target.row, target.col)}))
      .sort((a,b)=>a.d-b.d)[0];
    return best ? best.ord : Orders.UTRZYMAJ;
  }
  return Orders.UTRZYMAJ;
}

// Najbliższy mój piechur (inny niż u)
function nearestMyInfantry(G, u){
  const mine = G.units.filter(v =>
    v !== u && v.side === u.side && !v.dead && !v.escaped && !v.routed && v.type[0]==='P'
  );
  if (!mine.length) return null;
  mine.sort((a,b)=> distCells(u.row,u.col,a.row,a.col) - distCells(u.row,u.col,b.row,b.col));
  return mine[0];
}

// Wirtualna pozycja po danym rozkazie (jeśli legalny)
function nextPosForOrder(G, u, ord){
  const dir = ORIENT[u.side];
  const cand =
    ord===Orders.SZARZA    ? { row:u.row,             col:u.col + dir } :
    ord===Orders.SKOS_L    ? { row:stepRow(u.row,-1), col:u.col + dir } :
    ord===Orders.SKOS_P    ? { row:stepRow(u.row,+1), col:u.col + dir } :
    ord===Orders.PION_GORA ? { row:stepRow(u.row,-1), col:u.col } :
    ord===Orders.PION_DOL  ? { row:stepRow(u.row,+1), col:u.col } :
                             null;

  if (!cand || !cand.row) return null;

  // SKOS/SZARŻA muszą respektować strefę bitwy; PION – nie zmienia kolumny
  const respectBattleZone = (ord===Orders.SZARZA || ord===Orders.SKOS_L || ord===Orders.SKOS_P);
  const info = whyBlocked(G, u, cand, { respectBattleZone });
  return info.blocked ? null : cand;
}

// Ocena „jak bardzo zacieśniam szyk” (mniejsze = lepiej)
// 1) absolutna różnica od mediany rzędu, 2) dystans do najbliższego piechura
function cohesionScore(G, pos, u){
  const medianIdx = (function(){
    const ps = G.units.filter(x => x.side===u.side && !x.dead && !x.escaped && !x.routed && x.type[0]==='P');
    if (!ps.length) return rIdx(u.row);
    const idxs = ps.map(p => rIdx(p.row)).sort((a,b)=>a-b);
    return idxs[Math.floor(idxs.length/2)];
  })();

  const rowDelta = Math.abs(rIdx(pos.row) - medianIdx);

  const buddy = nearestMyInfantry(G, {...u, row:pos.row, col:pos.col});
  const buddyDist = buddy ? (Math.abs(rIdx(pos.row)-rIdx(buddy.row)) + Math.abs(pos.col - buddy.col)) : 3;

  // MOCNY priorytet na pionowe „zjechanie” do mediany; potem sklejanie z kolegą
  return rowDelta * 10 + buddyDist;
}

// Wybór najlepszego rozkazu do zacieśniania (dopuszcza PION!)
function bestCohesionOrder(G, u){
  const candidates = [
    Orders.PION_GORA, Orders.PION_DOL,
    Orders.SKOS_L, Orders.SKOS_P,
    Orders.SZARŻA   // na końcu: by nie stać, jeśli pion/skosy zablokowane
  ];

  const playable = candidates
    .map(ord => ({ ord, pos: nextPosForOrder(G, u, ord) }))
    .filter(x => x.pos);

  if (!playable.length) return Orders.UTRZYMAJ;

  playable.forEach(x => x.score = cohesionScore(G, x.pos, u));
  playable.sort((a,b)=> a.score - b.score);

  return playable[0].ord;
}

function maybeSquareVsCav(G, side){
  const foe = side==='A'?'O':'A';
  const foeK = unitsCav(G,foe);
  if (foeK.length < 2) return;
  for (const p of unitsInf(G,side)){
    const d = Math.min(...foeK.map(k=> Math.abs(rIdx(p.row)-rIdx(k.row)) + Math.abs(p.col-k.col) ), 99);
    if (d <= 2) p.setTypeAndFormation('P□');
  }
}

function activeUnitsOnField(G){
  return G.units.filter(u => !u.dead && !u.escaped && !u.routed && u.row && u.col);
}
function currentCenterRowIdx(G){
  const on = activeUnitsOnField(G);
  if (!on.length) return rIdx('B');
  const idxs = on.map(u => rIdx(u.row));
  const minI = Math.min(...idxs), maxI = Math.max(...idxs);
  return Math.round((minI + maxI) / 2);
}

function setOrderOkrążaj(G,u){
  if (u.row === 'A') { G.setOrder(u, Orders.SKOS_P); return; }
  if (u.row === 'C') { G.setOrder(u, Orders.SKOS_L); return; }
  G.setOrder(u, u.side==='A' ? Orders.SKOS_P : Orders.SKOS_L);
}
function setOrderSzarza(G,u){ G.setOrder(u, Orders.SZARZA); }
function setOrderUtrzymuj(G,u){ G.setOrder(u, Orders.UTRZYMAJ); }

function isAhead(u, t){
  if (!t) return false;
  const dir = ORIENT[u.side];
  // „przede mną” = w stronę mojego domyślnego kierunku
  return dir === +1 ? (t.col >= u.col) : (t.col <= u.col);
}

// Ustaw rozkaz + zaloguj powód (ALE nie dla routed/dead/escaped)
function setOrderWithLog(G, side, docId, u, ord, why){
  if (u.routed || u.dead || u.escaped) return; // ← nic nie rób, nawet bez loga
  const prev = u.order;
  G.setOrder(u, ord); // G.setOrder i tak ma guard, ale tu tniemy też log
  const tag = `[${docId}|${side}]`;
  logMsg(`${tag} ${u.type[0]}${u.num} @ ${u.row}${u.col}: ${prev} → ${ord} — ${why}`);
}


// Krótki alias tworzony per-wołanie doktryny (żeby nie wołać side/docId ciągle)
function makeDoctrineSetter(G, side, docId){
  return (u, ord, why) => setOrderWithLog(G, side, docId, u, ord, why);
}


function applyDoctrineOrders(G, side, doctrineId){
  const me  = side;
  const foe = (side==='A'?'O':'A');

  const set = makeDoctrineSetter(G, me, doctrineId);
  for (const u of unitsSide(G, me)){
    set(u, Orders.UTRZYMAJ, 'reset rozkazów przed oceną doktryny');
  }

  switch (doctrineId){

    // (Przebicie Centrum) ===
    case 'D1': {
      // Faza 1: do pierwszego kontaktu — wszyscy SZARŻA
      if (G.firstContactStep == null){
        for (const u of unitsSide(G, me)) G.setOrder(u, Orders.SZARZA);
        break;
      }

      // Faza 2: wybieraj cel „najbliżej centrum” i idź najkrótszą drogą
      for (const u of unitsSide(G, me)){
        // walczący stoją (i tak nie ruszą w fazie ruchu)
        if (G.adjEnemies(u).length > 0){ G.setOrder(u, Orders.UTRZYMAJ); continue; }

        const t = targetNearestToCenter(G, u);
        if (!t){ G.setOrder(u, Orders.UTRZYMAJ); continue; }

        // „Najkrótsza droga” = legalny ruch, który najbardziej skraca dystans (używamy Twojej istniejącej logiki)
        // chooseOrderToward: najpierw „better” (skraca dystans), a gdy jest kilka — wybiera minimalizujący dystans po ruchu.
        const ord = chooseOrderToward(G, u, t);
        G.setOrder(u, ord);
      }
      break;
    }

    case 'D2': {
      const me = side;
      const units = myUnitsActive(G, me);

      // ==============================
      // FAZA 1 — do pierwszego kontaktu
      // ==============================
      if (G.firstContactStep == null){
        // Domyślnie: wszystkim wolnym daj SZARŻA
        for (const u of units){
          if (G.adjEnemies(u).length > 0) continue;   // walczący stoją
          G.setOrder(u, Orders.SZARZA);
        }

        // Skrajne jednostki: „one-gap” => skos (góra: SKOS_L, dół: SKOS_P)
        const { top, bottom } = edgeUnits(G, me);

        if (top && isActiveAndFree(G, top) && oneGapEnemyAhead(G, top)){
          const dir = ORIENT[top.side];
          const tgt = { row: stepRow(top.row, -1), col: top.col + dir };
          const ok = !whyBlocked(G, top, tgt, {respectBattleZone:true}).blocked;
          if (ok) G.setOrder(top, Orders.SKOS_L); // w górę + przód
        }

        if (bottom && isActiveAndFree(G, bottom) && oneGapEnemyAhead(G, bottom)){
          const dir = ORIENT[bottom.side];
          const tgt = { row: stepRow(bottom.row, +1), col: bottom.col + dir };
          const ok = !whyBlocked(G, bottom, tgt, {respectBattleZone:true}).blocked;
          if (ok) G.setOrder(bottom, Orders.SKOS_P); // w dół + przód
        }

        break;
      }

      // ==============================
      // FAZA 2 — po pierwszym kontakcie
      // ==============================

      // Lista wrogów już związanych walką (cele priorytetowe do wsparcia 2-na-1)
      const engagedFoEs = engagedEnemiesAgainstMySide(G, me);

      for (const u of units){
        // Walczący nic nie zmieniają (i tak nie ruszą się w fazie ruchu)
        if (G.adjEnemies(u).length > 0){ 
          G.setOrder(u, Orders.UTRZYMAJ);
          continue;
        }

        // (1) Jeśli SZARŻA spowoduje kontakt po wykonaniu ruchu — wybierz SZARŻĘ
        if (chargeCreatesContact(G, u)){
          G.setOrder(u, Orders.SZARZA);
          continue;
        }

        // (2) Wspieraj walkę: najkrótsza droga do wroga, który już walczy z moimi
        if (engagedFoEs.length){
          let best=null, bd=1e9;
          for (const e of engagedFoEs){
            const d = distCells(u.row, u.col, e.row, e.col);
            if (d < bd){ bd=d; best=e; }
          }
          if (best){
            G.setOrder(u, chooseOrderToward(G, u, best));
            continue;
          }
        }

        // (3) Fallback: najkrótsza droga do najbliższego wroga
        const nearest = nearestEnemyOf(G, u);
        G.setOrder(u, chooseOrderToward(G, u, nearest));
      }
      break;
    }


    case 'D3': {
      for (const u of unitsSide(G, me)){
        const t = nearestEnemyOf(G, u);
        const ord = nextOrderToward(G, u, t);
        G.setOrder(u, ord);
      }
      break;
    }

    // D4: FORTECA LINIOWA (statyczna: nic nie robi, tylko trzyma)
    case 'D4': {
      for (const u of unitsSide(G, me)) {
        set(u, Orders.UTRZYMAJ, 'forteca: utrzymaj pozycję');
      }
      break;
    }


    // D5: ELASTYCZNA OBRONA — czekaj do 1. kontaktu; potem wolne jednostki wspierają 2-na-1
    case 'D5': {
      const myUnits = unitsSide(G, me);

      // RESET: domyślnie wszyscy trzymają (żeby walczący nie ruszali)
      for (const u of myUnits) set(u, Orders.UTRZYMAJ, 'elastyczna: domyślnie trzymaj');

      // Do pierwszego kontaktu — absolutnie nic nie rób
      if (G.firstContactStep == null) break;

      // Zbierz wrogów, którzy JUŻ są w zwarciu z moimi (cele do 2-na-1)
      const engagedEnemies = new Set();
      for (const u of myUnits) {
        const adj = G.adjEnemies(u);
        for (const e of adj) engagedEnemies.add(e);
      }
      const engagedList = Array.from(engagedEnemies);

      // Dla każdej MOJEJ jednostki, która NIE jest w kontakcie — prowadź do najbliższego takiego celu
      for (const u of myUnits) {
        if (G.adjEnemies(u).length > 0) continue; // ci, co już walczą, stoją

        if (engagedList.length) {
          let best = null, bd = 1e9, bestOrd = null;
          for (const e of engagedList) {
            const { better, playable } = legalOrdersToward(G, u, e);
            const ok = (better.length || playable.length);
            if (!ok) continue; // odpuść nieosiągalnych w tej turze
            const d = distCells(u.row,u.col,e.row,e.col);
            if (d < bd){ 
              bd = d; best = e; 
              bestOrd = (better[0]?.ord) || playable[0].ord;
            }
          }
          if (best){
            set(u, bestOrd, `wspieraj 2-na-1 vs ${best.type[0]}${best.num} @ ${best.row}${best.col}`);
            continue;
          }
          // jeśli nie znaleziono osiągalnego celu – zostaje UTRZYMAJ (defensywna)
        }

        // (opcjonalny fallback — gdyby wyjątkowo nie było żadnego starcia,
        // zostawiamy UTRZYMAJ, bo doktryna jest defensywna)
      }
      break;
    }

    // D6: JEŻ I KOLCE — czekaj; po kontakcie: K atakuje, P zacieśnia szyk
    case 'D6': {
      const myUnits = unitsSide(G, me);

      // Domyślnie: wszyscy trzymają pozycje
      for (const u of myUnits) set(u, Orders.UTRZYMAJ, 'jeż: trzymaj pozycję');

      // Do pierwszego kontaktu nie robimy NIC
      if (G.firstContactStep == null) break;

      // Helpery
      const myInfAll = unitsInf(G, me);
      const myInfFree = myInfAll.filter(u => G.adjEnemies(u).length === 0);
      const myCavFree = unitsCav(G, me).filter(u => G.adjEnemies(u).length === 0);

      // --- Kawaleria: atakuj najbliższy cel (tylko wolne oddziały K)
      for (const k of myCavFree) {
        const t = nearestEnemyOf(G, k);
        const ord = nextOrderToward(G, k, t);
        set(k, ord, t ? `K: atak najbliższego (${t.type[0]}${t.num}@${t.row}${t.col})` : 'K: brak celu');
      }

      // --- Piechota: „stay cohesive” — dostrajanie do mediany rzędu; jeśli już blisko kogoś, stój
      if (myInfAll.length) {
        // mediana rzędu mojej piechoty
        const idxs = myInfAll.map(p => rIdx(p.row)).sort((a,b)=>a-b);
        const medianIdx = idxs[Math.floor(idxs.length/2)];

        const hasBuddy1 = (u)=>{
          return myInfAll.some(v => v!==u &&
            (Math.abs(rIdx(u.row)-rIdx(v.row)) + Math.abs(u.col - v.col) <= 1));
        };

        for (const p of myInfFree) {
          if (hasBuddy1(p)) {
            set(p, Orders.UTRZYMAJ, 'P: blisko sojusznika, utrzymaj');
          } else {
            // ZAMIANA: wybór najlepszego ruchu kohezji (pozwala na PION)
            const ord = bestCohesionOrder(G, p);
            set(p, ord, 'P: zacieśnianie szyku (kohezja)');
          }
        }
      }

      break;
    }


  }
}

/* ===== UI ===== */
function docById(id){ return DOCTRINES.find(d=>d.id===id); }

function ensureDescBoxes(){
  // wstawi dwa opisy pod toolbar z doktrynami (raz)
  let host = document.querySelectorAll('.toolbar')[1]; // ta z doktrynami
  if (!host) return;
  if (!document.getElementById('docADesc')){
    const a = document.createElement('div');
    a.id = 'docADesc';
    a.className = 'docdesc';
    host.insertAdjacentElement('afterend', a);
  }
  if (!document.getElementById('docODesc')){
    const o = document.createElement('div');
    o.id = 'docODesc';
    o.className = 'docdesc';
    document.getElementById('docADesc').insertAdjacentElement('afterend', o);
  }
}

function updateDoctrineDescs(){
  ensureDescBoxes();
  const aId = (typeof G?.selDocA === 'string') ? G.selDocA : elDocA.value;
  const oId = (typeof G?.selDocO === 'string') ? G.selDocO : elDocO.value;
  const a = docById(aId), o = docById(oId);
  const aBox = document.getElementById('docADesc');
  const oBox = document.getElementById('docODesc');
  if (a && aBox) aBox.innerHTML = `<strong>Doktryna A:</strong> ${a.name}<br>${a.desc}`;
  if (o && oBox) oBox.innerHTML = `<strong>Doktryna O:</strong> ${o.name}<br>${o.desc}`;
}


const elBoard=document.getElementById('board'),
      elStep=document.getElementById('step'),
      elWeather=document.getElementById('weather'),
      elSeed=document.getElementById('seed'),
      elAtt=document.getElementById('attList'),
      elDef=document.getElementById('defList'),
      elLog=document.getElementById('log'),
      elDocA=document.getElementById('doctrineA'),
      elDocO=document.getElementById('doctrineO'),
      elPlace=document.getElementById('placeMode'),
      elEditBox=document.getElementById('editBox'),
      elSelInfo=document.getElementById('selInfo'),
      elSelFormation=document.getElementById('selFormation');

let G=null, selectedKey=null;
const DOCTRINES_OPTS = DOCTRINES
  .map(d => `<option value="${d.id}" title="${d.desc.replace(/"/g,'&quot;')}">${d.name}</option>`)
  .join('');

function terrainCls(t){
  return t==='.' ? 'plain'
       : t==='L' ? 'forest'
       : t==='W' ? 'hill'
       :           'water';
}

function parseArmy(s){ return s.split(',').map(x=>x.trim()).filter(Boolean); }
function logMsg(m){ elLog.textContent+=(elLog.textContent?'\n':'')+m; elLog.scrollTop=elLog.scrollHeight; }
function flash(n){ n.classList.add('selected'); setTimeout(()=>n.classList.remove('selected'),250); }
function unitAtKey(key){ if(!key) return null; const r=key[0], c=parseInt(key.slice(1),10); return G.unitAt(r,c); }
// Domyślne ilości (możesz zmienić)
const COUNTS = {
  A: { P: 2, K: 1 },
  O: { P: 2, K: 1 }
};

// Bezpieczna zmiana liczby z ograniczeniem
function clampInt(v, min, max){ return Math.max(min, Math.min(max, v)); }

// Ile maksymalnie sensownie mieści się na starcie? (np. 6 na stronę)
const MAX_TOTAL_PER_SIDE = 6;

// Uaktualnij widok liczników
function renderCounters(){
  for (const side of ['A','O']){
    document.getElementById(`${side}-P`).textContent = COUNTS[side].P;
    document.getElementById(`${side}-K`).textContent = COUNTS[side].K;
  }
}

function deadSpriteSrc(u){
  const side = (u.side === 'A') ? 'p1' : 'p2';
  const typ  = (u.type[0] === 'K') ? 'k' : 'p';
  return `battle_images/${side}_${typ}_dead.png`;
}


// Z ilości robi listę znaków ['P','P', ... 'K']
function listFromCounts(counts){
  const arr = [];
  for(let i=0;i<counts.P;i++) arr.push('P');
  for(let i=0;i<counts.K;i++) arr.push('K');
  return arr;
}

// Przebuduj jednostki po stronie na bazie liczników
function rebuildSideFromCounts(G, side){
  const list = listFromCounts(COUNTS[side]);
  // usuń stare jednostki tej strony
  G.units = G.units.filter(u => u.side !== side);

  // dodaj nowe (domyślne formacje: P=LINIA, K=KLIN)
  let p=0, k=0;
  list.forEach(T => {
    const n = (T === 'K') ? ++k : ++p;
    G.units.push(new Unit(side, T, n));
  });
}

function fillFormationSelect(u){
  elSelFormation.innerHTML='';
  const opt=(v,l)=>{ const o=document.createElement('option'); o.value=v; o.textContent=l; return o; };
  if(u.type[0]==='P'){
    elSelFormation.appendChild(opt('P','Piechota — linia'));
    elSelFormation.appendChild(opt('P~','Piechota — szachownica'));
    elSelFormation.appendChild(opt('P□','Piechota — czworobok'));
    elSelFormation.value = (u.type==='P'||u.formation==='LINIA') ? 'P' : (u.type==='P~'?'P~':'P□');
  } else {
    elSelFormation.appendChild(opt('K','Kawaleria — klin'));
    elSelFormation.appendChild(opt('K_lin','Kawaleria — linia'));
    elSelFormation.value = (u.formation==='LINIA'?'K_lin':'K');
  }
  elSelInfo.textContent = `${u.type[0]}${u.num} (${u.side}) @ ${u.row}${u.col} — trafienia:${u.hits} ${u.routed?'[UCIECZKA]':''}`;
}

/* --- sprite file name builder --- */
function playerId(side){ return side==='A' ? 'p1' : 'p2'; }
function typeId(u){ return (u.type[0]==='P') ? 'p' : 'k'; }
function formationId(u){
  // Kawaleria może mieć LINIA lub KLIN
  if (u.type[0]==='K'){
    return (u.formation==='KLIN') ? 'klin' : 'linia';
  }
  // Piechota: LINIA / SZACH / CZWOR
  if (u.formation==='LINIA') return 'linia';
  if (u.formation==='SZACH') return 'szachownica';
  if (u.formation==='CZWOR') return 'czworobok';
  return 'linia';
}

function orientationId(u){
  // jeśli kiedykolwiek się poruszył w poziomie, mamy _lastFacing
  if (typeof u._lastFacing === 'number'){
    return u._lastFacing === +1 ? 'prawo' : 'lewo';
  }
  // fallback: „naprzód” według sytuacji na polu, a na końcu po stronie
  const fwd = (typeof G?.advanceDir === 'function') ? G.advanceDir(u) : (u.side === 'A' ? +1 : -1);
  return fwd === +1 ? 'prawo' : 'lewo';
}

/**
 * Zwraca URL do obrazka jednostki.
 * 1) próbuje pełny:  p1_p_linia_prawo.png
 * 2) fallback bez orient.: p1_p_linia.png
 * 3) fallback bardzo ogólny: p1_p.png
 */
function buildSpriteSrcs(u){
  const base = `battle_images/${playerId(u.side)}_${typeId(u)}_${formationId(u)}`;
  const withOrient = `${base}_${orientationId(u)}.png`;
  const noOrient   = `${base}.png`;
  const typeOnly = `battle_images/${playerId(u.side)}_${typeId(u)}.png`;
  return [withOrient, noOrient, typeOnly];
}


function renderBoard(){
  elBoard.innerHTML='';
  ROWS.forEach(r=>{
    COLS.forEach(c=>{
      const cell=document.createElement('div'); cell.className=`cell ${terrainCls(G.map[r][c])}`;
      const cc=document.createElement('div'); cc.className='coords'; cc.textContent=`${r}${c}`; cell.appendChild(cc);

      const deadHere = G.units.filter(x => x.dead && x.row === r && x.col === c);
      for (const d of deadHere){
        const corpse = document.createElement('div');
        corpse.className = 'corpse-sprite';
        const img = document.createElement('img');
        img.className = 'unit-img';
        img.src = deadSpriteSrc(d);
        corpse.appendChild(img);
        cell.appendChild(corpse);
      }

      const u=G.unitAt(r,c);
      if (u && !u.dead && !u.escaped) {
        // obramówka kafla wg stanu
        if (u.routed) {
          cell.classList.add('routed-cell');
        } else if (u.bloodied) {
          cell.classList.add('bloodied-cell');
        }

        const holder = document.createElement('div');
        holder.className = `unit-sprite ${u.routed ? 'routed' : (u.bloodied ? 'bloodied' : '')}`;
        if (selectedKey && selectedKey === `${r}${c}`) holder.classList.add('selected');

        // obrazek jednostki (z Twojej bieżącej wersji)
        const img = document.createElement('img');
        img.className = 'unit-img';
        const sources = buildSpriteSrcs(u);
        let idx = 0;
        img.src = sources[idx];
        img.onerror = function(){
          idx++;
          if (idx < sources.length) this.src = sources[idx];
          else this.onerror = null;
        };
        holder.appendChild(img);

        if (u.routed) {
          const flag = document.createElement('div');
          flag.className = 'flag';
          holder.appendChild(flag);
        }
        if (u.hits > 0) {
          const hits = document.createElement('div');
          hits.className = 'hits';
          hits.textContent = `${u.hits}×`;
          holder.appendChild(hits);
        }

        holder.addEventListener('click', (ev) => {
          if (!elPlace.checked) return;
          ev.stopPropagation();
          selectedKey = `${r}${c}`;
          renderBoard();
        });

        cell.appendChild(holder);
      }



      cell.addEventListener('click', ()=>{
        if (!SETUP_ROWS.includes(r)) { flash(cell); return; }
        if(!elPlace.checked || !selectedKey) return;
        const u=unitAtKey(selectedKey); if(!u || u.dead || u.escaped){ selectedKey=null; renderBoard(); return; }
        const t=G.map[r][c]; if(t==='~') { flash(cell); return; }
        if(G.unitAt(r,c)) { flash(cell); return; }
        // Rozmieszczanie ograniczone do strefy bitwy
        if (c<BTL_MIN || c>BTL_MAX){ flash(cell); return; }
        u.row=r; u.col=c; selectedKey=null; renderBoard();
      });

      elBoard.appendChild(cell);
    });
  });

  const selUnit = unitAtKey(selectedKey);
  document.getElementById('editBox').style.display = (elPlace.checked && selUnit && !selUnit.dead && !selUnit.escaped) ? 'block' : 'none';
  if (selUnit) fillFormationSelect(selUnit);
  elStep.textContent=G.step; elWeather.value=G.weather;
}

function startGame(){
  // zachowujemy pogodę i seed z UI, ale skład z liczników
  const weather = elWeather.value;
  const seed = parseInt(elSeed.value || '123', 10);

  G.start({
    attacker: listFromCounts(COUNTS.A),
    defender: listFromCounts(COUNTS.O),
    weather,
    seed
  });

  elLog.textContent='';
  selectedKey=null;
  renderBoard();
}

/* ===== init + kontrolki ===== */
window.addEventListener('DOMContentLoaded', ()=>{
  elDocA.innerHTML=DOCTRINES_OPTS; elDocO.innerHTML=DOCTRINES_OPTS; elDocA.value='D1'; elDocO.value='D4';
  G=new Game(); startGame();

  // po elDocA/elDocO istnieją:
  elDocA.addEventListener('change', updateDoctrineDescs);
  elDocO.addEventListener('change', updateDoctrineDescs);
  updateDoctrineDescs(); // pierwszy render

  document.getElementById('btnStart').addEventListener('click', startGame);
  document.getElementById('btnReset').addEventListener('click', ()=>{ G=new Game(); elDocA.innerHTML=DOCTRINES_OPTS; elDocO.innerHTML=DOCTRINES_OPTS; elDocA.value='D1'; elDocO.value='D2'; startGame(); });
  document.getElementById('btnRandomMap').addEventListener('click', ()=>{ const s=Math.floor(Math.random()*1e9); document.getElementById('seed').value=String(s); G.randomMap(s); renderBoard(); });
  document.getElementById('btnAutoPlace').addEventListener('click', ()=>{ G.autoPlaceAll(); selectedKey=null; renderBoard(); });

  document.getElementById('btnStep').addEventListener('click', ()=>{
    if(G.finished){ logMsg(G.endMsg || 'Bitwa zakończona.'); return; }
    selectedKey=null; renderBoard();
    applyDoctrineOrders(G,'A',elDocA.value);
    applyDoctrineOrders(G,'O',elDocO.value);
    ensureProgressPair(G);
    const ended=G.doOneMicroStep(logMsg); renderBoard();
    if(ended){ logMsg(G.endMsg || 'Koniec.'); }
  });

  document.getElementById('btnToAuto').addEventListener('click', ()=>{
    if(G.finished){ logMsg(G.endMsg || 'Bitwa zakończona.'); return; }
    selectedKey=null; renderBoard();
    let guard=0; while(!G.finished && guard++<160){
      applyDoctrineOrders(G,'A',elDocA.value);
      applyDoctrineOrders(G,'O',elDocO.value);
      ensureProgressPair(G);
      const ended=G.doOneMicroStep(logMsg); renderBoard(); if(ended) break;
    }
    if(G.finished){ logMsg(G.endMsg); }
  });

  document.getElementById('btnFinish').addEventListener('click', ()=>{
    if(!G.finished){ G.finish(); }
    logMsg(G.endMsg);
  });

  document.getElementById('btnApplyFormation').addEventListener('click', ()=>{
    const u=unitAtKey(selectedKey); if(!u || u.dead || u.escaped) return;
    const val=document.getElementById('selFormation').value;
    if (u.type[0]==='P'){
      if (val==='P') u.setTypeAndFormation('P'); else if (val==='P~') u.setTypeAndFormation('P~'); else if (val==='P□') u.setTypeAndFormation('P□');
    } else { if (val==='K') u.setTypeAndFormation('K'); else if (val==='K_lin'){ u.type='K'; u.formation='LINIA'; } }
    renderBoard();
  });
  
  // Inicjalizacja liczników na starcie
  renderCounters();

  // Kliknięcia +/- na stepperach
  document.querySelectorAll('.stepper .btn-step').forEach(btn => {
    btn.addEventListener('click', () => {
      const side = btn.closest('.stepper').dataset.side;  // 'A' lub 'O'
      const type = btn.dataset.type;                      // 'P' lub 'K'
      const delta = parseInt(btn.dataset.delta, 10);      // +1 lub -1

      const otherType = (type === 'P') ? 'K' : 'P';

      // Wylicz nową wartość z ograniczeniami
      let newVal = COUNTS[side][type] + delta;
      newVal = clampInt(newVal, 0, MAX_TOTAL_PER_SIDE);

      // Łączna liczba nie może przekroczyć MAX_TOTAL_PER_SIDE
      const totalOther = COUNTS[side][otherType];
      if (newVal + totalOther > MAX_TOTAL_PER_SIDE){
        newVal = MAX_TOTAL_PER_SIDE - totalOther;
      }

      COUNTS[side][type] = newVal;
      renderCounters();
    });
  });

  // „Zastosuj składy”
  document.getElementById('btnApplyArmy').addEventListener('click', () => {
    rebuildSideFromCounts(G, 'A');
    rebuildSideFromCounts(G, 'O');
    G.autoPlaceAll();
    selectedKey = null;
    logMsg('Zastosowano składy na podstawie liczników P/K.');
    renderBoard();
  });

});
</script>
</body>
</html>

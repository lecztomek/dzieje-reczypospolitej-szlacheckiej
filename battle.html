<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<title>Bitwa 6×3 (+bufor) — czerwony A, niebieski O</title>
<style>
  :root { --cell:72px; --gap:6px; --bg:#0f1220; --panel:#161a2f; --grid:#222846; --text:#e7e9f3; }
  html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font:14px/1.4 system-ui,Segoe UI,Roboto,sans-serif}
  .wrap{display:flex;gap:16px;padding:16px}
  .board-wrap{display:flex;flex-direction:column;gap:10px}
  .board{display:grid;grid-template-columns:repeat(8,var(--cell));grid-auto-rows:var(--cell);gap:var(--gap);background:var(--grid);padding:var(--gap);border-radius:12px;box-shadow:0 0 0 1px #0008 inset,0 8px 30px #0007}
  .cell{position:relative;border-radius:10px;display:flex;align-items:center;justify-content:center;outline:1px solid #0006;overflow:hidden;cursor:default}
  .coords{position:absolute;top:4px;left:6px;font-size:11px;opacity:.6}
  .plain{background:#283058} .forest{background:linear-gradient(135deg,#194d2a,#0e2917)}
  .hill{background:linear-gradient(135deg,#6e5c2f,#493b1f)} .bog{background:linear-gradient(135deg,#3a2e4a,#231a30)}
  .water{background:linear-gradient(135deg,#0a3a6e,#041e3a)} .ford{background:repeating-linear-gradient(135deg,#0a3a6e 0 14px,#8f7a46 14px 18px)}

  /* Żetony */
  .unit{ position:relative; width:48px; height:42px; display:flex; align-items:center; justify-content:center;
         color:#fff; font-weight:800; text-shadow:0 1px 0 #000a; box-shadow:0 6px 16px #0008; border:2px solid #0008;
         cursor:pointer; user-select:none; }
  /* KOLORY: A= czerwony, O = niebieski */
  .A{ background:linear-gradient(#d31b1b,#8f1212); }
  .O{ background:linear-gradient(#2e62ff,#1942c9); }

  .bloodied{ filter:saturate(1.25) contrast(1.15); box-shadow:0 0 0 2px #ffbf00 inset, 0 8px 16px #000a; border-color:#ffbf00aa; }
  .routed{ filter:grayscale(.25) saturate(.5) brightness(1.55) opacity(.55); border-color:#bbb8; box-shadow:0 0 0 2px #ffffff44 inset, 0 8px 16px #000a; }
  .selected{ outline:3px solid #fff8; box-shadow:0 0 0 2px #fff3 inset,0 8px 16px #000a; }
  .unit .letter{ font-size:16px; text-shadow:0 1px 0 #000a, 0 0 6px #0008; }

  /* Kształty formacji */
  .f-linia{ border-radius:999px; width:58px; height:34px; }
  .f-czwor{ width:42px; height:42px; border-radius:8px; }
  .f-szach{ width:42px; height:42px; clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%); }
  /* Klin jako normalny kontener + clip-path (łatwe centrowanie literki) */
  .f-klin{
    width:46px; height:44px; border-radius:0; background:transparent;
    box-shadow:0 6px 16px #0008; border:2px solid #0008;
  }
  /* A (czerwony) szpic w PRAWO, O (niebieski) szpic w LEWO */
  .A.f-klin{
    background:linear-gradient(#d31b1b,#8f1212);
    clip-path: polygon(0 0, 100% 50%, 0 100%);           /* ► */
  }
  .O.f-klin{
    background:linear-gradient(#2e62ff,#1942c9);
    clip-path: polygon(100% 0, 0 50%, 100% 100%);        /* ◄ */
  }
  /* Literka w klinie – NIE absolute; centrowanie bierze się z flexa rodzica .unit */
  .f-klin .letter{
    position:static;
    width:auto; height:auto;
  }

  /* Odznaki */
  .flag{ position:absolute; top:2px; left:2px; width:0; height:0; border-left:10px solid #ddd; border-top:6px solid transparent; border-bottom:6px solid transparent; filter:drop-shadow(0 1px 0 #000a); }
  .hits{ position:absolute; bottom:2px; right:4px; font-size:11px; font-weight:900; text-shadow:0 1px 0 #000; opacity:.9 }

  /* Panele/UI */
  .side{width:700px;background:var(--panel);border-radius:12px;padding:14px;box-shadow:0 8px 30px #0007}
  .sec{margin-bottom:14px} .sec h3{margin:0 0 8px;font-size:15px;letter-spacing:.2px}
  .row{display:flex;gap:8px;align-items:center;margin-bottom:8px;flex-wrap:wrap}
  select,input[type=text],button{background:#0e1330;color:var(--text);border:1px solid #313867;border-radius:10px;padding:8px 10px}
  button{background:#1f2760;border-color:#4250a9;cursor:pointer;font-weight:600} button:hover{filter:brightness(1.1)}
  .log{height:320px;overflow:auto;background:#0b0f26;border:1px solid #2b335f;border-radius:10px;padding:10px;white-space:pre-wrap}
  .legend{font-size:12px;opacity:.8}
  .toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .sep{flex:1 1 auto}
  .tag{padding:2px 8px;border-radius:8px;background:#0e1330;border:1px solid #313867}
  .pill{padding:2px 8px;border-radius:999px;background:#0e1330;border:1px solid #313867; font-size:12px}
  
  .stepper { display:flex; align-items:center; gap:8px; }
  .stepper .gap { width:16px; }
  .stepper-label { opacity:.85; margin-right:4px; }
  .btn-step{
    width:28px; height:28px; line-height:26px; padding:0;
    display:inline-flex; align-items:center; justify-content:center;
    border-radius:8px; border:1px solid #4250a9; background:#1f2760; font-weight:900;
  }
  .stepper-val{
    min-width:22px; text-align:center; font-weight:800; display:inline-block;
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="board-wrap">
    <div class="toolbar">
      <strong>Mikro-krok: <span id="step">0</span></strong>
      <span>• Pogoda:</span>
      <select id="weather">
        <option value="pogodnie">pogodnie</option>
        <option value="deszcz">deszcz</option>
        <option value="bloto">błoto</option>
      </select>
      <span>• Seed:</span><input id="seed" value="123" style="width:80px"/>
      <button id="btnStart">Start</button>
      <button id="btnReset">Reset</button>
      <label><input type="checkbox" id="placeMode" checked/> Tryb rozmieszczania</label>
    </div>
    <div class="toolbar">
      <span class="tag">Doktryna A:</span><select id="doctrineA"></select>
      <span class="tag">Doktryna O:</span><select id="doctrineO"></select>
      <button id="btnAutoPlace">Auto-rozmieszczenie</button>
      <button id="btnRandomMap">Losuj mapę</button>
      <span class="sep"></span>
      <button id="btnStep">Krok mikro</button>
      <button id="btnToAuto">Do autokońca</button>
      <button id="btnFinish">Koniec</button>
    </div>
    <div id="board" class="board"></div>
  </div>

  <div class="side">
    <div class="sec">
      <h3>Skład armii</h3>

      <!-- ATAKUJĄCY -->
      <div class="row">
        <label style="min-width:90px">Atakujący:</label>
        <div class="stepper" data-side="A">
          <span class="stepper-label">P:</span>
          <button class="btn-step" data-type="P" data-delta="-1">−</button>
          <span class="stepper-val" id="A-P">2</span>
          <button class="btn-step" data-type="P" data-delta="1">+</button>
          <span class="gap"></span>
          <span class="stepper-label">K:</span>
          <button class="btn-step" data-type="K" data-delta="-1">−</button>
          <span class="stepper-val" id="A-K">1</span>
          <button class="btn-step" data-type="K" data-delta="1">+</button>
        </div>
      </div>

      <!-- OBRONCA -->
      <div class="row">
        <label style="min-width:90px">Obrońca:</label>
        <div class="stepper" data-side="O">
          <span class="stepper-label">P:</span>
          <button class="btn-step" data-type="P" data-delta="-1">−</button>
          <span class="stepper-val" id="O-P">2</span>
          <button class="btn-step" data-type="P" data-delta="1">+</button>
          <span class="gap"></span>
          <span class="stepper-label">K:</span>
          <button class="btn-step" data-type="K" data-delta="-1">−</button>
          <span class="stepper-val" id="O-K">1</span>
          <button class="btn-step" data-type="K" data-delta="1">+</button>
        </div>
      </div>

      <div class="row">
        <button id="btnApplyArmy">Zastosuj składy</button>
      </div>
    </div>

    <div class="sec" id="editBox" style="display:none">
      <h3>Edycja zaznaczonej jednostki</h3>
      <div class="row"><div>Jednostka:</div><div id="selInfo" class="pill">—</div></div>
      <div class="row">
        <label>Formacja:</label>
        <select id="selFormation"></select>
        <button id="btnApplyFormation">Zmień</button>
      </div>
    </div>

    <div class="sec"><h3>Log</h3><div id="log" class="log"></div></div>
    <div class="sec legend">
      <div><strong>Koniec gry:</strong> kliknij <em>Koniec</em> albo nastąpi auto, gdy jedna strona nie ma już zdolnych do walki (wszyscy zabici lub w ucieczce).</div>
      <div><strong>Kontakt:</strong> sąsiadujące (N/S/E/W) wrogie żetony walczą od razu i nie ruszają się w tym kroku.</div>
      <div><strong>Strefa bitwy:</strong> kol. 2–7; normalny ruch nie wychodzi poza tę strefę. Uciekinierzy mogą cofać się do kol. 1/8 i dopiero poza planszę „uciekają”.</div>
    </div>
  </div>
</div>

<script>
/* ===== Parametry planszy ===== */
const ROWS = ["X","A","B","C","Y"];      // X = bufor ponad, Y = bufor poniżej
const SETUP_ROWS = ["A","B","C"];        // tylko tu wolno rozstawiać

const COLS=[1,2,3,4,5,6,7,8];
const BTL_MIN=2, BTL_MAX=7; // strefa bitwy = 2..7
const ORIENT={A:+1,O:-1};

const Terrain={PLAIN:'.',FOREST:'L',HILL:'W',BOG:'B',WATER:'~',FORD:'='};
const Orders={UTRZYMAJ:'UTRZYMAJ', NAPRZOD:'NAPRZOD', SZARZA:'SZARZA', SKOS_L:'SKOS_L', SKOS_P:'SKOS_P', PRZES_L:'PRZES_L', PRZES_P:'PRZES_P', PRZECHWYC:'PRZECHWYC', OBRONA_SKRZYDLA:'OBRONA_SKRZYDLA'};
const Weather={POGODNIE:'pogodnie',DESZCZ:'deszcz',BLOTO:'bloto'};
const clamp=(v,min,max)=>Math.max(min,Math.min(max,v)), rIdx=r=>ROWS.indexOf(r), stepRow=(r,d)=>ROWS[rIdx(r)+d]||null, d6=()=>1+Math.floor(Math.random()*10);

class Unit{
  constructor(side,type,num){
    this.side=side; this.type=type; this.num=num;
    this.row=null; this.col=null;
    this.order=Orders.UTRZYMAJ; this.flankGuard=false;
    this.hits=0; this.routed=false; this.bloodied=false; this.dead=false; this.escaped=false;
    this.didKill=false;

    this.formation = (type==='P~'?'SZACH' : type==='P□'?'CZWOR' : (type[0]==='K'?'KLIN':'LINIA'));

    // NOWE: klin – bonus przy pierwszym ataku
    this._wedgeFirstAttackDone = false;
  }

  setTypeAndFormation(t){
    const prev = this.formation;           // NOWE
    this.type=t;
    this.formation = (t==='P~'?'SZACH' : t==='P□'?'CZWOR' : (t[0]==='K'?'KLIN':'LINIA'));

    // NOWE: jeśli przechodzimy na KLIN z innej formacji, zresetuj „pierwszy atak”
    if (this.formation==='KLIN' && prev!=='KLIN'){
      this._wedgeFirstAttackDone = false;
    }
  }
}


/* ===== Pomoc diagnostyczna dla ruchu ===== */
const cellStr = (r,c)=> `${r}${c}`;
const unitKey = (u) => `${u.side}:${u.type}:${u.num}`; // np. "A:K:1", "O:P□:2"

function whyBlocked(G, u, t, {respectBattleZone=true} = {}){
  if (!t || !t.row)         return { blocked:true, reason:'brak kafla (krawędź planszy)' };
  if (t.col < COLS[0] || t.col > COLS[COLS.length-1])
                           return { blocked:true, reason:'poza planszą' };
  if (respectBattleZone && (t.col < BTL_MIN || t.col > BTL_MAX))
                           return { blocked:true, reason:'poza strefą bitwy (2–7)' };
  if (G.map[t.row][t.col] === Terrain.WATER)
                           return { blocked:true, reason:`woda na ${cellStr(t.row,t.col)}` };
	const ally = G.unitAt(t.row, t.col);
	if (ally && ally === u) return { blocked:false, reason:'' }; // to jest ten sam żeton
  if (ally && ally.side === u.side && !ally.dead && !ally.escaped)
                           return { blocked:true, reason:`sojusznik na ${cellStr(t.row,t.col)}` };
  const foe  = G.enemyAt(t.row, t.col, u.side);
  if (foe)                  return { blocked:true, reason:`wróg na ${cellStr(t.row,t.col)} (walka tylko w fazie 0)` };
  return { blocked:false, reason:'' };
}


class Game{
  constructor(){ this.map=this.emptyMap(); this.units=[]; this.weather=Weather.POGODNIE; this.step=0; this.finished=false; this.endMsg=''; }
  emptyMap(){ const m={}; ROWS.forEach(r=>{ m[r]={}; COLS.forEach(c=> m[r][c]=Terrain.PLAIN ); }); return m; }
  randomMap(seed=123){
    const R=()=>Math.random(); 
    this.map=this.emptyMap();

    // wiersze, na których NIE rozstawiamy graczy
    const waterRows = ROWS.filter(r => !SETUP_ROWS.includes(r));

    // Woda/ford tylko w strefie bitwy (2–7) i NIGDY na A/B/C
    if (R()<0.35 && waterRows.length){
      const rr = waterRows[Math.floor(R()*waterRows.length)];
      const sc = 4+Math.floor(R()*2); // 4..5 start w środku
      for(let c=sc;c<=BTL_MAX;c++) this.map[rr][c]=Terrain.WATER;
      const fordCol = clamp(sc, BTL_MIN, BTL_MAX-1);
      this.map[rr][fordCol]=Terrain.FORD;
    }

    // Lasy
    for(let i=0,n=1+Math.floor(R()*3);i<n;i++){
      const r=ROWS[Math.floor(R()*ROWS.length)], c=BTL_MIN+Math.floor(R()*(BTL_MAX-BTL_MIN+1));
      this.map[r][c]=Terrain.FOREST; if (c<BTL_MAX && R()<0.6) this.map[r][c+1]=Terrain.FOREST;
    }
    // Bagna (w środku)
    for(let i=0,n=Math.floor(R()*3);i<n;i++){
      const r=ROWS[Math.floor(R()*ROWS.length)], c=4+Math.floor(R()*3);
      const cc=clamp(c, BTL_MIN, BTL_MAX);
      this.map[r][cc]=Terrain.BOG;
    }
    // Wzgórza
    for(let i=0,n=1+Math.floor(R()*2);i<n;i++){
      const r=ROWS[Math.floor(R()*ROWS.length)], c=2+Math.floor(R()*5);
      const cc=clamp(c, BTL_MIN, BTL_MAX);
      this.map[r][cc]=Terrain.HILL;
    }
  }
  
	advanceDir(u){
	  // Domyślny kierunek (A: +1, O: -1)
	  const def = ORIENT[u.side];

	  // Bierzemy pod uwagę tylko zdolnych do walki wrogów (ignoruj routed/escaped/dead)
	  const foes = this.units.filter(x =>
		!x.dead && !x.escaped && !x.routed && x.side !== u.side
	  );

	  if (!foes.length) return def;

	  // Czy ktoś jest "z przodu" względem domyślnego kierunku?
	  const anyForward  = foes.some(f => def === +1 ? (f.col >= u.col) : (f.col <= u.col));
	  // Czy ktoś jest "z tyłu"?
	  const anyBackward = foes.some(f => def === +1 ? (f.col <  u.col) : (f.col >  u.col));

	  // Jeśli z przodu brak, a z tyłu są — zawróć
	  if (!anyForward && anyBackward) return -def;

	  return def;
	}


  start({attacker=["K","P","P"],defender=["P~","P","K"],weather='pogodnie',seed=123}={}){
    this.weather=weather; this.step=0; this.finished=false; this.endMsg=''; this.units=[]; this.randomMap(seed);
    const addSide=(s,arr)=>{ let p=0,k=0; arr.forEach(t=>{ let type=(t==='P~'||t==='P□')?t:t.toUpperCase(); if (type==='P[]'||type==='P#') type='P□'; const n=type[0]==='K'? ++k : ++p; this.units.push(new Unit(s,type,n)); }); };
    addSide('A',attacker); addSide('O',defender); this.autoPlaceAll();
  }
  clearPositions(){ this.units.forEach(u=>{ if(!u.dead && !u.escaped){ u.row=null; u.col=null; } }); }
  autoPlace(side){
    const cols=side==='A'?[2,3]:[7,6]; // rozmieszczenie w strefie bitwy
    const slots=[]; for(const c of cols){ for(const r of SETUP_ROWS) slots.push([r,c]); }
    let i=0; this.units.filter(u=>u.side===side&&!u.dead&&!u.escaped).forEach(u=>{
      let s=null; while(i<slots.length){ const cand=slots[i++]; if(!this.unitAt(cand[0],cand[1])){ s=cand; break; } }
      if(!s) s=slots[slots.length-1]; u.row=s[0]; u.col=s[1];
    });
  }
  autoPlaceAll(){ this.clearPositions(); this.autoPlace('A'); this.autoPlace('O'); }
  unitAt(r,c){ return this.units.find(u=>!u.dead && !u.escaped && u.row===r && u.col===c); }
  enemyAt(r,c,side){ return this.units.find(u=>!u.dead && !u.escaped && u.row===r && u.col===c && u.side!==side); }
  setOrder(u,ord){ if(u.routed||u.dead||u.escaped) return; u.order=ord; u.flankGuard=(ord===Orders.OBRONA_SKRZYDLA); }

  adjEnemies(u){
    if (u.routed) return []; // jednostka w ucieczce nie walczy
    const n=[[0,1],[0,-1],[-1,0],[1,0]];
    const out=[];
    for(const [dr,dc] of n){
      const rr=ROWS[rIdx(u.row)+dr]; const cc=u.col+dc;
      if(!rr||cc<COLS[0]||cc>COLS[COLS.length-1]) continue;
      const e=this.enemyAt(rr,cc,u.side);
      if(e && !e.routed) out.push(e); // <- pomiń uciekających
    }
    return out;
  }

  registerHit(victim, log){
    victim.hits++;
    if (victim.hits>=2){
      victim.dead=true;
      log(`   ✖ ${victim.type[0]}${victim.num}(${victim.side}) GINIE (2. trafienie).`);
      return;
    }
    const flee = Math.random()<0.5;
    if (flee){ victim.routed=true; victim.bloodied=false; log(`   ⚑ ${victim.type[0]}${victim.num}(${victim.side}) U-C-I-E-K-A (załamanie szyku).`); }
    else { victim.bloodied=true; victim.routed=false; log(`   ✚ ${victim.type[0]}${victim.num}(${victim.side}) POZOSTAJE (krwawi).`); }
  }

	/* ===== Walka z modyfikatorami ===== */
	combat(u1, u2, ctx, log){
	  if (u1.dead||u2.dead||u1.escaped||u2.escaped) return;
	  if (u1.routed||u2.routed) return;

	  // Progi bazowe i „notatniki” modyfikatorów (osobno dla każdej jednostki)
	  let need1 = 8, need2 = 8;
	  const m1 = [], m2 = [];

	  // Skróty
	  const isCav1 = u1.type[0] === 'K', isCav2 = u2.type[0] === 'K';
	  const isInf1 = u1.type[0] === 'P', isInf2 = u2.type[0] === 'P';
	  const ter1 = this.map[u1.row][u1.col];
	  const ter2 = this.map[u2.row][u2.col];

	  const from1 = (ctx && ctx.from1) ? ctx.from1 : { row:u1.row, col:u1.col };
	  const from2 = (ctx && ctx.from2) ? ctx.from2 : { row:u2.row, col:u2.col };

	  // tylko FRONTALNOŚĆ (na potrzeby szarży/hill/ford)
	  const frontal12 = isFrontalFrom(u1, u2, from1);
	  const frontal21 = isFrontalFrom(u2, u1, from2);

	  const offensive = (u, opp, frontal) =>
		(u.order === Orders.SZARZA) && frontal; // „ofensywny” = SZARŻA + kontakt frontalny

	  // Kary kawalerii za teren/pogodę
	  const cavPenalty = (ter) => {
		let pen = 0;
		if (ter === 'L' || ter === 'B') pen = Math.max(pen, 2);
		if (this.weather === Weather.BLOTO) pen = Math.max(pen, 2);
		else if (this.weather === Weather.DESZCZ) pen = Math.max(pen, 1);
		return pen;
	  };
	  if (isCav1){ const p = cavPenalty(ter1); if (p){ need1 += p; m1.push(`+${p} kawaleria w ${nameTer(ter1)} / pogoda`); } }
	  if (isCav2){ const p = cavPenalty(ter2); if (p){ need2 += p; m2.push(`+${p} kawaleria w ${nameTer(ter2)} / pogoda`); } }

	  // Szarża kawalerii (per jednostka; frontalnie; na równinie; pogodnie)
	  if (isCav1 && offensive(u1, u2, frontal12) && ter2 === '.' && this.weather === Weather.POGODNIE) {
		need1--; m1.push('−1 kawaleria: szarża na równinie (pogodnie)');
	  }
	  if (isCav2 && offensive(u2, u1, frontal21) && ter1 === '.' && this.weather === Weather.POGODNIE) {
		need2--; m2.push('−1 kawaleria: szarża na równinie (pogodnie)');
	  }

	// Wzgórze
	if (ter1 === 'W' && frontal21) { need1--; m1.push('−1 obrona na wzgórzu'); need2++; m2.push('+1 atak pod górę'); }
	if (ter2 === 'W' && frontal12) { need2--; m2.push('−1 obrona na wzgórzu'); need1++; m1.push('+1 atak pod górę'); }

	// Bród (tylko piechota, i tylko gdy NIE ma SZARŻA)
	if (ter1 === '=' && isInf1 && frontal21 && u1.order !== Orders.SZARZA) {
	  need1 -= 2; m1.push('−2 piechota: obrona na brodzie');
	  need2 += 1; m2.push('+1 atak na brodzie (przeciw piechocie)');
	}
	if (ter2 === '=' && isInf2 && frontal12 && u2.order !== Orders.SZARZA) {
	  need2 -= 2; m2.push('−2 piechota: obrona na brodzie');
	  need1 += 1; m1.push('+1 atak na brodzie (przeciw piechocie)');
	}


	  // P~ w lesie: obrońca stojący w lesie −1; atakujący wchodzący w las −1
	  if (u1.type === 'P~' && ter1 === 'L') { need1--; m1.push('−1 piechota-szach w lesie (obrona)'); }
	  if (u1.type === 'P~' && this.map[u2.row][u2.col] === 'L' && frontal12) { need1--; m1.push('−1 piechota-szach idzie w las'); }
	  if (u2.type === 'P~' && ter2 === 'L') { need2--; m2.push('−1 piechota-szach w lesie (obrona)'); }
	  if (u2.type === 'P~' && this.map[u1.row][u1.col] === 'L' && frontal21) { need2--; m2.push('−1 piechota-szach idzie w las'); }

	  // P□ broni się lepiej vs kawaleria
	  if (u1.type === 'P□' && isCav2) { need1--; m1.push('−1 czworobok vs kawaleria'); }
	  if (u2.type === 'P□' && isCav1) { need2--; m2.push('−1 czworobok vs kawaleria'); }


	  const adjFoes1 = this.adjEnemies(u1).filter(x => !x.routed);
	  const adjFoes2 = this.adjEnemies(u2).filter(x => !x.routed);
	  if (adjFoes1.length >= 2) { need1 += 2; m1.push('+2 okrążenie'); need2--; m2.push('−1 okrążenie'); }
	  if (adjFoes2.length >= 2) { need2 += 2; m2.push('+2 okrążenie'); need1--; m1.push('−1 okrążenie'); }


	  // KLIN (u1)
	  if (u1.formation === 'KLIN') {
		if (offensive(u1, u2, frontal12)) {
		  if (!u1._wedgeFirstAttackDone) {
			need1 -= 3; m1.push('−3 klin: pierwszy atak (tylko przy SZARŻY)');
			u1._wedgeFirstAttackDone = true; // zużywamy tylko przy realnej szarży
		  } else {
			need1 += 1; m1.push('+1 klin: kolejne starcia (ofensywa)');
		  }
		} else {
		  need1 += 1; m1.push('+1 klin: słaba obrona'); // obrona zawsze +1, bez zużycia
		}
	  }

	  // KLIN (u2)
	  if (u2.formation === 'KLIN') {
		if (offensive(u2, u1, frontal21)) {
		  if (!u2._wedgeFirstAttackDone) {
			need2 -= 3; m2.push('−3 klin: pierwszy atak (tylko przy SZARŻY)');
			u2._wedgeFirstAttackDone = true;
		  } else {
			need2 += 1; m2.push('+1 klin: kolejne starcia (ofensywa)');
		  }
		} else {
		  need2 += 1; m2.push('+1 klin: słaba obrona');
		}
	  }


	// Pomocniki do rozpoznawania piechoty/kawalerii w liniach
	const isInfLine   = u => u.formation === 'LINIA' && u.type[0] === 'P';
	const isInfSquare = u => u.formation === 'CZWOR' && u.type[0] === 'P';
	const isInfSzach  = u => u.formation === 'SZACH'  && u.type[0] === 'P';

	// KARA tylko w starciu z LINIĄ PIECHOTY (P w LINIA).
	// LINIA KAWALERII (K w LINIA) NIE uruchamia kary.

	// Strona ①: P□ / P~ kontra linia piechoty (po stronie ②)
	if ((isInfSquare(u1) || isInfSzach(u1)) && isInfLine(u2)) {
	  need1 += 1;
	  m1.push('+1 (czworobok/szachownica piechoty vs linia piechoty)');
	}

	// Strona ②: P□ / P~ kontra linia piechoty (po stronie ①)
	if ((isInfSquare(u2) || isInfSzach(u2)) && isInfLine(u1)) {
	  need2 += 1;
	  m2.push('+1 (czworobok/szachownica piechoty vs linia piechoty)');
	}


	  // Przytnij progi do 2..10
	  need1 = clamp(need1, 2, 10);
	  need2 = clamp(need2, 2, 10);

	  // Rzuty (k10) i log
	  const r1 = d6(), r2 = d6();
	  const hit1 = r1 >= need1 && !u1.didKill;
	  const hit2 = r2 >= need2 && !u2.didKill;

	  log(`Starcie ${u1.type[0]}${u1.num}(${u1.side}) ⇄ ${u2.type[0]}${u2.num}(${u2.side})`);
	  log(`  ①: potrzeba ≥${need1} [${m1.length?m1.join('; '):'brak modyf.'}] | rzut=${r1}`);
	  log(`  ②: potrzeba ≥${need2} [${m2.length?m2.join('; '):'brak modyf.'}] | rzut=${r2}`);

	  if      (hit1 && hit2) log(`  → WYNIK: OBIE strony trafione.`);
	  else if (hit1)         log(`  → WYNIK: strona ① trafiła | ② pudłuje.`);
	  else if (hit2)         log(`  → WYNIK: strona ② trafiła | ① pudłuje.`);
	  else                   log(`  → WYNIK: nikt nie trafił.`);

	  if (hit1){ this.registerHit(u2, log); u1.didKill=true; }
	  if (hit2){ this.registerHit(u1, log); u2.didKill=true; }
	}


  isFlank(att,def,ctx){ const dr=rIdx(ctx.from.row)-rIdx(def.row), dc=ctx.from.col-def.col; const back=(ORIENT[def.side]===+1? dc<0: dc>0); return dr!==0 || back; }
  isFrontal(att,def){ const dc=att.col-def.col; return (ORIENT[def.side]===+1 ? dc<0 : dc>0); }

  /* ===== Ruch ===== */
  tryMove(u, r,c, {respectBattleZone=true}={}){
    if(!r) return false;
    if (c<COLS[0] || c>COLS[COLS.length-1]) return false;
    if (respectBattleZone && (c<BTL_MIN || c>BTL_MAX)) return false; // normalny ruch nie wychodzi poza 2..7
    const t=this.map[r][c]; if (t==='~') return false;
    if (this.unitAt(r,c)) return false;
    u.row=r; u.col=c; return true;
  }

  retreatStep(u){
    const dir = ORIENT[u.side];
    const candidates = [
      {r:u.row, c: u.col - dir},
      {r: stepRow(u.row,-1), c: u.col - dir},
      {r: stepRow(u.row,+1), c: u.col - dir},
    ];
    for (const t of candidates){
      if (!t.r) continue;
      // jeśli wyszło poza 1/8 => uciekł
      if (t.c < COLS[0] || t.c > COLS[COLS.length-1]) { u.escaped=true; return; }
      // w bufory 1/8 można wejść (respectBattleZone=false)
      if (this.tryMove(u, t.r, t.c, {respectBattleZone:false})) return;
    }
  }

  /* ===== Koniec + podsumowanie ===== */
  computeSummary(reason=''){
    const stats = (side)=>({
      dead: this.units.filter(u=>u.side===side && u.dead).length,
      escaped: this.units.filter(u=>u.side===side && u.escaped).length,
      routed: this.units.filter(u=>u.side===side && !u.dead && !u.escaped && u.routed).length,
      bloodied: this.units.filter(u=>u.side===side && !u.dead && !u.escaped && u.bloodied && !u.routed).length,
      active: this.units.filter(u=>u.side===side && !u.dead && !u.escaped && !u.routed).length,
      onField: this.units.filter(u=>u.side===side && !u.dead && !u.escaped).length
    });
    const A=stats('A'), O=stats('O');
    let winner='—';
    if (A.active===0 && O.active>0) winner='O';
    else if (O.active===0 && A.active>0) winner='A';
    else if (A.dead+A.escaped !== O.dead+O.escaped) winner = (A.dead+A.escaped < O.dead+O.escaped) ? 'A' : 'O';

    return `KONIEC${reason?`: ${reason}`:''}
Zwycięzca: ${winner==='—'?'brak (remis)':(winner==='A'?'Atakujący':'Obrońca')}

Atakujący (A):
  Zabici: ${A.dead} | Uciekli: ${A.escaped} | Zdolni do walki: ${A.active}
  Na polu (wszyscy nie-zabici): ${A.onField} | W ucieczce na polu: ${A.routed} | Krwawi (ale walczą): ${A.bloodied}

Obrońca (O):
  Zabici: ${O.dead} | Uciekli: ${O.escaped} | Zdolni do walki: ${O.active}
  Na polu (wszyscy nie-zabici): ${O.onField} | W ucieczce na polu: ${O.routed} | Krwawi (ale walczą): ${O.bloodied}`;
  }

  finish(reason='(na żądanie)'){ if (this.finished) return; this.finished = true; this.endMsg = this.computeSummary(reason); }

  autoFinishIfNoActives(){
    const aActive = this.units.some(u=>u.side==='A' && !u.dead && !u.escaped && !u.routed);
    const oActive = this.units.some(u=>u.side==='O' && !u.dead && !u.escaped && !u.routed);
    if (!aActive || !oActive){
      this.finished = true;
      const side = !aActive && oActive ? 'A' : (!oActive && aActive ? 'O' : '—');
      this.endMsg = this.computeSummary(side==='—'?'obie strony bez aktywnych':'armia '+side+' nie ma już zdolnych do walki');
      return true;
    }
    return false;
  }

  /* ===== Silnik kroku ===== */
  doOneMicroStep(log){
    if(this.finished) return true;
    this.units.forEach(u=>{u.didKill=false;});

    const stepNo = this.step + 1;
    log(`\n─────────────────[ MIKRO-KROK ${stepNo} ]─────────────────`);
    log('0) WALKA W KONTAKCIE');

	// 0) walka w kontakcie
	const engaged = new Set();
	const pairs = [];

	for (const u of this.units.filter(x => !x.dead && !x.escaped && !x.routed)) {
	  const adj = this.adjEnemies(u);
	  for (const e of adj) {
		const key = [unitKey(u), unitKey(e)].sort().join('|'); // unikalny klucz pary
		if (!pairs.find(p => p.key === key)) pairs.push({ a: u, b: e, key });
	  }
	}

	// zaznacz uczestników kontaktu
	for (const { a, b } of pairs) {
	  engaged.add(unitKey(a));
	  engaged.add(unitKey(b));
	}

	// rozdziel pary na frontalne i pozostałe
	const frontalPairs = [];
	const nonFrontalPairs = [];
	for (const { a, b, key } of pairs) {
	  // „frontalne” = obie strony mają kontakt od frontu względem orientacji przeciwnika
	  const abFront = this.isFrontal(a, b);
	  const baFront = this.isFrontal(b, a);
	  if (abFront && baFront) frontalPairs.push({ a, b, key });
	  else nonFrontalPairs.push({ a, b, key });
	}

	// jeśli są frontalne – rozgrywamy tylko je; w przeciwnym razie rozgrywamy flankowe
	const toResolve = frontalPairs.length > 0 ? frontalPairs : nonFrontalPairs;

	if (frontalPairs.length > 0 && nonFrontalPairs.length > 0) {
	  log(`(priorytet: ${frontalPairs.length} starć FRONTALNYCH; pozostałe w kontakcie czekają)`);
	}

	for (const { a, b } of toResolve) {
	  log(`(kontakt: ${a.type[0]}${a.num} z ${b.type[0]}${b.num})`);
		this.combat(a, b, {
		  from1: { row: a.row, col: a.col },
		  from2: { row: b.row, col: b.col }
		}, log);

	  if (this.finished) { log(this.endMsg); return true; }
	}


    // 1) Uciekinierzy
    log('1) UCIECZKI');
    this.units.filter(u=>!u.dead && !u.escaped && u.routed).forEach(u=> this.retreatStep(u));

	// 2) RUCH (bez nowych starć)
	log('2) RUCH (bez nowych starć)');

	this.units
	  .filter(u => !u.dead && !u.escaped)
	  .forEach(u => {
		if (u.routed){
		  log(`(stoi ${u.type[0]}${u.num}(${u.side}): w ucieczce)`);
		} else if (engaged.has(unitKey(u))){
		  log(`(stoi ${u.type[0]}${u.num}(${u.side}): był w kontakcie w tej turze)`);
		} else if (u.order === Orders.UTRZYMAJ){
		  log(`(stoi ${u.type[0]}${u.num}(${u.side}): rozkaz UTRZYMAJ)`);
		}
	  });


	const prio = [Orders.SZARZA, Orders.NAPRZOD, Orders.SKOS_L, Orders.SKOS_P, Orders.PRZES_L, Orders.PRZES_P, Orders.PRZECHWYC];

	const canTryMove = (u) =>
	  !u.dead && !u.escaped && !u.routed && !engaged.has(unitKey(u));

	const moved = new Set();
	const markMoved   = (u) => moved.add(unitKey(u));
	const notMovedYet = (u) => !moved.has(unitKey(u));

	const isCav = (u) => u.type[0] === 'K';
	const isInf = (u) => u.type[0] === 'P';


	const runWave = (filterFn, label) => {
	  if (label) log(`(fala ruchu: ${label})`);
	  for (const p of prio) {
		// **opcjonalne sortowanie**: np. numerem (od mniejszych do większych)
		const group = this.units
		  .filter(u => canTryMove(u) && notMovedYet(u) && filterFn(u) && u.order === p)
		  .sort((a,b) => a.num - b.num);

		for (const u of group) {
		  const ok = this.applyMove(u, log);
		  if (ok) markMoved(u);   // oznaczamy jako ruszone TYLKO gdy faktycznie się poruszył
		  if (this.finished) { log(this.endMsg); return true; }
		}
	  }
	  return false;
	};

	// 1) Kawaleria atakującego
	if (runWave(u => u.side==='A' && isCav(u), 'kawaleria A')) return true;
	// 2) Kawaleria obrońcy
	if (runWave(u => u.side==='O' && isCav(u), 'kawaleria O')) return true;
	// 3) Piechota atakującego
	if (runWave(u => u.side==='A' && isInf(u), 'piechota A')) return true;
	// 4) Piechota obrońcy
	if (runWave(u => u.side==='O' && isInf(u), 'piechota O')) return true;
	// 5) Pozostali (druga szansa po „odkorkowaniu”)
	if (runWave(u => true, 'pozostali')) return true;



    // 3) Autokońiec, jeśli brak zdolnych do walki
    if (this.autoFinishIfNoActives()){ return true; }

    this.step++;
    return this.finished;
  }

  distToEnemy(u){ const foes=this.units.filter(x=>!x.dead && !x.escaped && x.side!==u.side); if(!foes.length) return 999;
    return foes.map(f=>Math.abs(rIdx(u.row)-rIdx(f.row))+Math.abs(u.col-f.col)).sort((a,b)=>a-b)[0]; }

	applyMove(u, log){
	  const dir = this.advanceDir(u);
	  let didMove = false;

	  const tryGo = (r,c,opts)=> this.tryMove(u,r,c,opts);

	  const canEnter = (t) => {
		if (!t || !t.row) return false;
		if (t.col < COLS[0] || t.col > COLS[COLS.length-1]) return false;
		if (this.map[t.row][t.col] === Terrain.WATER) return false;
		return true;
	  };

	  const tryMoveWithWhy = (target, {respectBattleZone=true}={})=>{
		const info = whyBlocked(this, u, target, {respectBattleZone});
		if (info.blocked){
		  log(`(brak ruchu ${u.type[0]}${u.num}(${u.side}): ${info.reason})`);
		  return false;
		}
		const from = cellStr(u.row,u.col), to = cellStr(target.row,target.col);
		if (this.tryMove(u, target.row, target.col, {respectBattleZone})){
		  log(`ruch ${u.type[0]}${u.num}(${u.side}): ${from} → ${to}`);
		  u._lastMovedStep = this.step;
		  u._lastOrderAtMove = u.order;
		  didMove = true;

		  // piechota w czworoboku (P□) po ruchu staje się linią (P)
		  if (u.type[0] === 'P' && u.formation === 'CZWOR') {
			u.setTypeAndFormation('P'); // ustawi formację = LINIA i typ = 'P'
			log(`(P${u.num}(${u.side}) przechodzi z czworoboku do linii po ruchu)`);
		  }

		  return true;
		}
		log(`(brak ruchu ${u.type[0]}${u.num}(${u.side}): nie można wejść na ${to})`);
		return false;
	  };

	  const targetFor = (ord)=>{
		switch(ord){
		  case Orders.NAPRZOD: return {row:u.row, col:u.col+dir};
		  case Orders.SZARZA:  return {row:u.row, col:u.col+dir};
		  case Orders.SKOS_L:  return {row:stepRow(u.row,-1), col:u.col+dir};
		  case Orders.SKOS_P:  return {row:stepRow(u.row,+1), col:u.col+dir};
		  case Orders.PRZES_L: return {row:u.row, col:u.col-1};
		  case Orders.PRZES_P: return {row:u.row, col:u.col+1};
		  case Orders.PRZECHWYC:{
			const fwd=this.unitAt(u.row,u.col+dir);
			return fwd ? {row:u.row, col:u.col} : {row:u.row, col:u.col+dir};
		  }
		  default: return {row:u.row, col:u.col};
		}
	  };

	  const isDiagonal = (u.order===Orders.SKOS_L || u.order===Orders.SKOS_P);
	  let tgt = targetFor(u.order);

	  if (isDiagonal){
		const dCol = dir;
		const dRowPref = (u.order===Orders.SKOS_L ? -1 : +1);
		const rowPref = stepRow(u.row, dRowPref);
		const rowAlt  = stepRow(u.row, -dRowPref);
		const primary = rowPref ? {row: rowPref, col: u.col + dCol} : null;
		const alt     = rowAlt  ? {row: rowAlt,  col: u.col + dCol} : null;
		const forward = {row: u.row, col: u.col + dCol};

		if (primary && tryMoveWithWhy(primary)) return true;
		if (alt     && tryMoveWithWhy(alt))     return true;
		if (tryMoveWithWhy(forward))            return true;

		const upDown1 = rowPref ? {row: rowPref, col: u.col} : null;
		const upDown2 = rowAlt  ? {row: rowAlt,  col: u.col} : null;

		if (upDown1 && tryMoveWithWhy(upDown1)) return true;
		if (upDown2 && tryMoveWithWhy(upDown2)) return true;

		return false;
	  }

	  // Ruch prosty / przechwyty
	  tryMoveWithWhy(tgt);

	  return didMove;
	}


}

function nameTer(t){ return t==='.'?'równina': t==='L'?'las': t==='W'?'wzgórze': t==='B'?'bagno': t==='~'?'woda':'bród'; }
// FRONT od strony `from` względem orientacji przeciwnika
// FRONT od strony `from` względem orientacji przeciwnika
// FRONT od strony `from` – zawsze TAK
function isFrontalFrom(att, def, from){
  return true;
}

// FLANK/TYŁ – wyłączamy całkiem
function isFlankFrom(att, def, from){
  return false;
}


/* ===== Doktryny ===== */
const DOCTRINES = [
  { id:'D1',  name:'P utrzymuj, K okrążaj' },
  { id:'D2',  name:'P utrzymuj, K szarża' },
  { id:'D3',  name:'P szarża, K utrzymuj' },
  { id:'D4',  name:'P szarża, K okrążaj' },
  { id:'D5',  name:'Wszystkie szarża' },
  { id:'D6',  name:'Wszystkie utrzymuj' },
  { id:'D7',  name:'P okrążaj, K szarża' },
  { id:'D8',  name:'P okrążaj, K utrzymuj' },
  { id:'D9',  name:'Centrum szarża, flanki okrążaj' },
  { id:'D10', name:'Centrum utrzymuj, flanki szarża' },
  { id:'D11', name:'Centrum szarża, flanki utrzymuj' },
  { id:'D12', name:'Centrum szarża, flanki okrążaj' },
];

function setOrderOkrążaj(G,u){
  if (u.row === 'A') { G.setOrder(u, Orders.SKOS_P); return; }
  if (u.row === 'C') { G.setOrder(u, Orders.SKOS_L); return; }
  G.setOrder(u, u.side==='A' ? Orders.SKOS_P : Orders.SKOS_L);
}
function setOrderSzarza(G,u){ G.setOrder(u, Orders.SZARZA); }
function setOrderUtrzymuj(G,u){ G.setOrder(u, Orders.UTRZYMAJ); }

function applyDoctrineOrders(G, side, doctrineId){
  const us=G.units.filter(u=>u.side===side&&!u.dead&&!u.escaped&&!u.routed);
  const P=us.filter(u=>u.type[0]==='P'), K=us.filter(u=>u.type[0]==='K');
  const center=us.filter(u=>u.row==='B'), flanks=us.filter(u=>u.row!=='B');
  us.forEach(u=>G.setOrder(u,Orders.UTRZYMAJ));
  switch(doctrineId){
    case 'D1': P.forEach(setOrderUtrzymuj.bind(null,G)); K.forEach(setOrderOkrążaj.bind(null,G)); break;
    case 'D2': P.forEach(setOrderUtrzymuj.bind(null,G)); K.forEach(setOrderSzarza.bind(null,G)); break;
    case 'D3': P.forEach(setOrderSzarza.bind(null,G));  K.forEach(setOrderUtrzymuj.bind(null,G)); break;
    case 'D4': P.forEach(setOrderSzarza.bind(null,G));  K.forEach(setOrderOkrążaj.bind(null,G)); break;
    case 'D5': us.forEach(setOrderSzarza.bind(null,G)); break;
    case 'D6': us.forEach(setOrderUtrzymuj.bind(null,G)); break;
    case 'D7': P.forEach(setOrderOkrążaj.bind(null,G)); K.forEach(setOrderSzarza.bind(null,G)); break;
    case 'D8': P.forEach(setOrderOkrążaj.bind(null,G)); K.forEach(setOrderUtrzymuj.bind(null,G)); break;
    case 'D9': center.forEach(setOrderSzarza.bind(null,G)); flanks.forEach(setOrderOkrążaj.bind(null,G)); break;
    case 'D10':center.forEach(setOrderUtrzymuj.bind(null,G)); flanks.forEach(setOrderSzarza.bind(null,G)); break;
    case 'D11':center.forEach(setOrderSzarza.bind(null,G)); flanks.forEach(setOrderUtrzymuj.bind(null,G)); break;
    case 'D12':center.forEach(setOrderSzarza.bind(null,G)); flanks.forEach(setOrderOkrążaj.bind(null,G)); break;
  }
}

/* ===== UI ===== */
const elBoard=document.getElementById('board'),
      elStep=document.getElementById('step'),
      elWeather=document.getElementById('weather'),
      elSeed=document.getElementById('seed'),
      elAtt=document.getElementById('attList'),
      elDef=document.getElementById('defList'),
      elLog=document.getElementById('log'),
      elDocA=document.getElementById('doctrineA'),
      elDocO=document.getElementById('doctrineO'),
      elPlace=document.getElementById('placeMode'),
      elEditBox=document.getElementById('editBox'),
      elSelInfo=document.getElementById('selInfo'),
      elSelFormation=document.getElementById('selFormation');

let G=null, selectedKey=null;
const DOCTRINES_OPTS = DOCTRINES.map(d=>`<option value="${d.id}">${d.name}</option>`).join('');

function terrainCls(t){ return t==='.'?'plain': t==='L'?'forest': t==='W'?'hill': t==='B'?'bog': t==='~'?'water':'ford'; }
function parseArmy(s){ return s.split(',').map(x=>x.trim()).filter(Boolean); }
function logMsg(m){ elLog.textContent+=(elLog.textContent?'\n':'')+m; elLog.scrollTop=elLog.scrollHeight; }
function flash(n){ n.classList.add('selected'); setTimeout(()=>n.classList.remove('selected'),250); }
function unitAtKey(key){ if(!key) return null; const r=key[0], c=parseInt(key.slice(1),10); return G.unitAt(r,c); }
// Domyślne ilości (możesz zmienić)
const COUNTS = {
  A: { P: 2, K: 1 },
  O: { P: 2, K: 1 }
};

// Bezpieczna zmiana liczby z ograniczeniem
function clampInt(v, min, max){ return Math.max(min, Math.min(max, v)); }

// Ile maksymalnie sensownie mieści się na starcie? (np. 6 na stronę)
const MAX_TOTAL_PER_SIDE = 6;

// Uaktualnij widok liczników
function renderCounters(){
  for (const side of ['A','O']){
    document.getElementById(`${side}-P`).textContent = COUNTS[side].P;
    document.getElementById(`${side}-K`).textContent = COUNTS[side].K;
  }
}

// Z ilości robi listę znaków ['P','P', ... 'K']
function listFromCounts(counts){
  const arr = [];
  for(let i=0;i<counts.P;i++) arr.push('P');
  for(let i=0;i<counts.K;i++) arr.push('K');
  return arr;
}

// Przebuduj jednostki po stronie na bazie liczników
function rebuildSideFromCounts(G, side){
  const list = listFromCounts(COUNTS[side]);
  // usuń stare jednostki tej strony
  G.units = G.units.filter(u => u.side !== side);

  // dodaj nowe (domyślne formacje: P=LINIA, K=KLIN)
  let p=0, k=0;
  list.forEach(T => {
    const n = (T === 'K') ? ++k : ++p;
    G.units.push(new Unit(side, T, n));
  });
}

function fillFormationSelect(u){
  elSelFormation.innerHTML='';
  const opt=(v,l)=>{ const o=document.createElement('option'); o.value=v; o.textContent=l; return o; };
  if(u.type[0]==='P'){
    elSelFormation.appendChild(opt('P','Piechota — linia'));
    elSelFormation.appendChild(opt('P~','Piechota — szachownica'));
    elSelFormation.appendChild(opt('P□','Piechota — czworobok'));
    elSelFormation.value = (u.type==='P'||u.formation==='LINIA') ? 'P' : (u.type==='P~'?'P~':'P□');
  } else {
    elSelFormation.appendChild(opt('K','Kawaleria — klin'));
    elSelFormation.appendChild(opt('K_lin','Kawaleria — linia'));
    elSelFormation.value = (u.formation==='LINIA'?'K_lin':'K');
  }
  elSelInfo.textContent = `${u.type[0]}${u.num} (${u.side}) @ ${u.row}${u.col} — trafienia:${u.hits} ${u.routed?'[UCIECZKA]':''}`;
}

function renderBoard(){
  elBoard.innerHTML='';
  ROWS.forEach(r=>{
    COLS.forEach(c=>{
      const cell=document.createElement('div'); cell.className=`cell ${terrainCls(G.map[r][c])}`;
      const cc=document.createElement('div'); cc.className='coords'; cc.textContent=`${r}${c}`; cell.appendChild(cc);

      const u=G.unitAt(r,c);
      if(u && !u.dead && !u.escaped){
        let fClass='f-linia'; if (u.formation==='CZWOR') fClass='f-czwor'; else if (u.formation==='SZACH') fClass='f-szach'; else if (u.formation==='KLIN') fClass='f-klin';
        const chip=document.createElement('div'); chip.className=`unit ${u.side} ${fClass} ${u.routed?'routed':(u.bloodied?'bloodied':'')}`;
        const letter=document.createElement('div'); letter.className='letter'; letter.textContent=(u.type[0]==='P'?'P':'K')+u.num;
        chip.appendChild(letter);

        if (u.routed){ const flag=document.createElement('div'); flag.className='flag'; chip.appendChild(flag); }
        if (u.hits>0){ const hits=document.createElement('div'); hits.className='hits'; hits.textContent=`${u.hits}×`; chip.appendChild(hits); }

        if (selectedKey && selectedKey===`${r}${c}`) chip.classList.add('selected');
        chip.addEventListener('click',(ev)=>{ if(!elPlace.checked) return; ev.stopPropagation(); selectedKey=`${r}${c}`; renderBoard(); });

        cell.appendChild(chip);
      }

      cell.addEventListener('click', ()=>{
        if (!SETUP_ROWS.includes(r)) { flash(cell); return; }
        if(!elPlace.checked || !selectedKey) return;
        const u=unitAtKey(selectedKey); if(!u || u.dead || u.escaped){ selectedKey=null; renderBoard(); return; }
        const t=G.map[r][c]; if(t==='~') { flash(cell); return; }
        if(G.unitAt(r,c)) { flash(cell); return; }
        // Rozmieszczanie ograniczone do strefy bitwy
        if (c<BTL_MIN || c>BTL_MAX){ flash(cell); return; }
        u.row=r; u.col=c; selectedKey=null; renderBoard();
      });

      elBoard.appendChild(cell);
    });
  });

  const selUnit = unitAtKey(selectedKey);
  document.getElementById('editBox').style.display = (elPlace.checked && selUnit && !selUnit.dead && !selUnit.escaped) ? 'block' : 'none';
  if (selUnit) fillFormationSelect(selUnit);
  elStep.textContent=G.step; elWeather.value=G.weather;
}

function startGame(){
  // zachowujemy pogodę i seed z UI, ale skład z liczników
  const weather = elWeather.value;
  const seed = parseInt(elSeed.value || '123', 10);

  G.start({
    attacker: listFromCounts(COUNTS.A),
    defender: listFromCounts(COUNTS.O),
    weather,
    seed
  });

  elLog.textContent='';
  selectedKey=null;
  renderBoard();
}

/* ===== init + kontrolki ===== */
window.addEventListener('DOMContentLoaded', ()=>{
  elDocA.innerHTML=DOCTRINES_OPTS; elDocO.innerHTML=DOCTRINES_OPTS; elDocA.value='D1'; elDocO.value='D2';
  G=new Game(); startGame();

  document.getElementById('btnStart').addEventListener('click', startGame);
  document.getElementById('btnReset').addEventListener('click', ()=>{ G=new Game(); elDocA.innerHTML=DOCTRINES_OPTS; elDocO.innerHTML=DOCTRINES_OPTS; elDocA.value='D1'; elDocO.value='D2'; startGame(); });
  document.getElementById('btnRandomMap').addEventListener('click', ()=>{ const s=Math.floor(Math.random()*1e9); document.getElementById('seed').value=String(s); G.randomMap(s); renderBoard(); });
  document.getElementById('btnAutoPlace').addEventListener('click', ()=>{ G.autoPlaceAll(); selectedKey=null; renderBoard(); });

  document.getElementById('btnStep').addEventListener('click', ()=>{
    if(G.finished){ logMsg(G.endMsg || 'Bitwa zakończona.'); return; }
    selectedKey=null; renderBoard();
    applyDoctrineOrders(G,'A',elDocA.value);
    applyDoctrineOrders(G,'O',elDocO.value);
    const ended=G.doOneMicroStep(logMsg); renderBoard();
    if(ended){ logMsg(G.endMsg || 'Koniec.'); }
  });

  document.getElementById('btnToAuto').addEventListener('click', ()=>{
    if(G.finished){ logMsg(G.endMsg || 'Bitwa zakończona.'); return; }
    selectedKey=null; renderBoard();
    let guard=0; while(!G.finished && guard++<160){
      applyDoctrineOrders(G,'A',elDocA.value);
      applyDoctrineOrders(G,'O',elDocO.value);
      const ended=G.doOneMicroStep(logMsg); renderBoard(); if(ended) break;
    }
    if(G.finished){ logMsg(G.endMsg); }
  });

  document.getElementById('btnFinish').addEventListener('click', ()=>{
    if(!G.finished){ G.finish(); }
    logMsg(G.endMsg);
  });

  document.getElementById('btnApplyFormation').addEventListener('click', ()=>{
    const u=unitAtKey(selectedKey); if(!u || u.dead || u.escaped) return;
    const val=document.getElementById('selFormation').value;
    if (u.type[0]==='P'){
      if (val==='P') u.setTypeAndFormation('P'); else if (val==='P~') u.setTypeAndFormation('P~'); else if (val==='P□') u.setTypeAndFormation('P□');
    } else { if (val==='K') u.setTypeAndFormation('K'); else if (val==='K_lin'){ u.type='K'; u.formation='LINIA'; } }
    renderBoard();
  });
  
  // Inicjalizacja liczników na starcie
  renderCounters();

  // Kliknięcia +/- na stepperach
  document.querySelectorAll('.stepper .btn-step').forEach(btn => {
    btn.addEventListener('click', () => {
      const side = btn.closest('.stepper').dataset.side;  // 'A' lub 'O'
      const type = btn.dataset.type;                      // 'P' lub 'K'
      const delta = parseInt(btn.dataset.delta, 10);      // +1 lub -1

      const otherType = (type === 'P') ? 'K' : 'P';

      // Wylicz nową wartość z ograniczeniami
      let newVal = COUNTS[side][type] + delta;
      newVal = clampInt(newVal, 0, MAX_TOTAL_PER_SIDE);

      // Łączna liczba nie może przekroczyć MAX_TOTAL_PER_SIDE
      const totalOther = COUNTS[side][otherType];
      if (newVal + totalOther > MAX_TOTAL_PER_SIDE){
        newVal = MAX_TOTAL_PER_SIDE - totalOther;
      }

      COUNTS[side][type] = newVal;
      renderCounters();
    });
  });

  // „Zastosuj składy”
  document.getElementById('btnApplyArmy').addEventListener('click', () => {
    rebuildSideFromCounts(G, 'A');
    rebuildSideFromCounts(G, 'O');
    G.autoPlaceAll();
    selectedKey = null;
    logMsg('Zastosowano składy na podstawie liczników P/K.');
    renderBoard();
  });

});
</script>
</body>
</html>
